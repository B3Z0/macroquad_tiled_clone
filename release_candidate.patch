diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
new file mode 100644
index 0000000..b56b5c0
--- /dev/null
+++ b/.github/workflows/ci.yml
@@ -0,0 +1,17 @@
+name: CI
+
+on: [push, pull_request]
+
+jobs:
+  build:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+      - uses: actions-rs/toolchain@v1
+        with:
+          toolchain: stable
+          components: rustfmt, clippy
+      - run: cargo fmt -- --check
+      - run: cargo clippy -- -D warnings
+      - run: cargo test
+      - run: cargo check --examples
diff --git a/CHANGELOG.md b/CHANGELOG.md
new file mode 100644
index 0000000..ee1ff1e
--- /dev/null
+++ b/CHANGELOG.md
@@ -0,0 +1,9 @@
+# Changelog
+
+All notable changes to this project will be documented in this file.
+
+## [0.1.0] - 2026-02-21
+
+- Initial public release.
+- Tiled JSON loading for tile layers and external tilesets.
+- Basic rendering via Macroquad.
diff --git a/Cargo.lock b/Cargo.lock
index 5e94a7a..6fff7fd 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -136,6 +136,12 @@ dependencies = [
  "png",
 ]
 
+[[package]]
+name = "itoa"
+version = "1.0.15"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4a5f13b858c8d314ee3e8f639011f7ccefe71f97f96e50151fb991f267928e2c"
+
 [[package]]
 name = "libc"
 version = "0.2.174"
@@ -168,7 +174,8 @@ version = "0.1.0"
 dependencies = [
  "anyhow",
  "macroquad",
- "nanoserde",
+ "serde",
+ "serde_json",
 ]
 
 [[package]]
@@ -180,6 +187,12 @@ dependencies = [
  "libc",
 ]
 
+[[package]]
+name = "memchr"
+version = "2.7.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0"
+
 [[package]]
 name = "miniquad"
 version = "0.4.8"
@@ -202,21 +215,6 @@ dependencies = [
  "simd-adler32",
 ]
 
-[[package]]
-name = "nanoserde"
-version = "0.2.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a36fb3a748a4c9736ed7aeb5f2dfc99665247f1ce306abbddb2bf0ba2ac530a4"
-dependencies = [
- "nanoserde-derive",
-]
-
-[[package]]
-name = "nanoserde-derive"
-version = "0.2.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "a846cbc04412cf509efcd8f3694b114fc700a035fb5a37f21517f9fb019f1ebc"
-
 [[package]]
 name = "ndk-sys"
 version = "0.2.2"
@@ -254,24 +252,97 @@ dependencies = [
  "miniz_oxide",
 ]
 
+[[package]]
+name = "proc-macro2"
+version = "1.0.95"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "02b3e5e68a3a1a02aad3ec490a98007cbc13c37cbe84a3cd7b8e406d76e7f778"
+dependencies = [
+ "unicode-ident",
+]
+
 [[package]]
 name = "quad-rand"
 version = "0.2.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "5a651516ddc9168ebd67b24afd085a718be02f8858fe406591b013d101ce2f40"
 
+[[package]]
+name = "quote"
+version = "1.0.40"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
+dependencies = [
+ "proc-macro2",
+]
+
+[[package]]
+name = "ryu"
+version = "1.0.20"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "28d3b2b1366ec20994f1fd18c3c594f05c5dd4bc44d8bb0c1c632c8d6829481f"
+
+[[package]]
+name = "serde"
+version = "1.0.219"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5f0e2c6ed6606019b4e29e69dbaba95b11854410e5347d525002456dbbb786b6"
+dependencies = [
+ "serde_derive",
+]
+
+[[package]]
+name = "serde_derive"
+version = "1.0.219"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5b0276cf7f2c73365f7157c8123c21cd9a50fbbd844757af28ca1f5925fc2a00"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
+[[package]]
+name = "serde_json"
+version = "1.0.142"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "030fedb782600dcbd6f02d479bf0d817ac3bb40d644745b769d6a96bc3afc5a7"
+dependencies = [
+ "itoa",
+ "memchr",
+ "ryu",
+ "serde",
+]
+
 [[package]]
 name = "simd-adler32"
 version = "0.3.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d66dc143e6b11c1eddc06d5c423cfc97062865baf299914ab64caa38182078fe"
 
+[[package]]
+name = "syn"
+version = "2.0.104"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "17b6f705963418cdb9927482fa304bc562ece2fdd4f616084c50b7023b435a40"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "unicode-ident",
+]
+
 [[package]]
 name = "ttf-parser"
 version = "0.21.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "2c591d83f69777866b9126b24c6dd9a18351f177e49d625920d19f989fd31cf8"
 
+[[package]]
+name = "unicode-ident"
+version = "1.0.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512"
+
 [[package]]
 name = "winapi"
 version = "0.3.9"
diff --git a/Cargo.toml b/Cargo.toml
index 7cbcf28..d923548 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -2,14 +2,19 @@
 name = "macroquad_tiled_clone"
 version = "0.1.0"
 edition = "2021"
-authors = ["Your Name <you@example.com>"]
+authors = ["B3Z0 <vlad.cotiga75@gmail.com>"]
 license = "MIT OR Apache-2.0"
 description = "Minimal Tiled JSON loader & renderer for Macroquad"
+repository = "https://github.com/B3Z0/macroquad_tiled_clone.git"
+readme = "README.md"
+keywords = ["tiled", "macroquad", "tilemap", "gamedev"]
+categories = ["game-development", "graphics"]
 
 [dependencies]
 macroquad = "0.4"               # for rendering & textures
-nanoserde = "0.2.1"              # for zero-alloc JSON parsing
-# (Later you can swap to serde + serde_json if desired)
+serde_json = "1.0.142"
+serde = { version = "1.0", features = ["derive"] }
+anyhow = "1.0"
 
 [dev-dependencies]
 anyhow = "1.0"                 # for quick prototyping of errors in examples/tests
diff --git a/LICENSE-APACHE b/LICENSE-APACHE
new file mode 100644
index 0000000..d9a10c0
--- /dev/null
+++ b/LICENSE-APACHE
@@ -0,0 +1,176 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
diff --git a/LICENSE-MIT b/LICENSE-MIT
new file mode 100644
index 0000000..e140be0
--- /dev/null
+++ b/LICENSE-MIT
@@ -0,0 +1,21 @@
+MIT License
+
+Copyright (c) 2026 B3Z0
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..75aec17
--- /dev/null
+++ b/README.md
@@ -0,0 +1,68 @@
+# macroquad_tiled_clone
+
+Minimal Tiled JSON loader and renderer for Macroquad.
+
+## Supports
+
+- Tiled JSON maps (orthogonal) with external tilesets (`source` .json)
+- Tile layers (finite) with `data` arrays
+- Object layers (`objectgroup`)
+- Tile objects (`gid`)
+- Multiple tilesets (firstgid mapping)
+- Per-layer offsets
+- Properties on map/layer/object/tileset/tile
+- Tile flip/rotation flags from Tiled GIDs
+- Rendering via `draw_texture_ex` with nearest filtering
+- Universal draw API: `map.draw(view_min, view_max)` (tiles + tile-objects)
+- Optional debug outlines via `set_debug_draw(true)`
+
+## Not yet
+
+- Infinite maps (chunked layers)
+- Image layers
+- Group layers
+- Embedded tilesets
+- Base64/compressed layer data
+- Isometric or hex maps
+- Tile animations
+
+## Rendering API
+
+- `draw(view_min, view_max)`: draws tiles + tile-objects, and draws debug outlines when `debug_draw` is enabled.
+- `draw_visible_rect(view_min, view_max)`: draws tiles only (advanced/manual flow).
+
+## Quickstart
+
+1. Add to your project:
+   ```toml
+   macroquad_tiled_clone = { git = "https://github.com/B3Z0/macroquad_tiled_clone.git" }
+   ```
+2. Run the example:
+   ```bash
+   cargo run --example basic_map
+   ```
+3. Load and draw a map:
+   ```rust
+   use macroquad::prelude::*;
+   use macroquad_tiled_clone::map::Map;
+
+   #[macroquad::main("My Game")]
+   async fn main() {
+       let map = Map::load("assets2/map.json")
+           .await
+           .expect("Failed to load map");
+
+       loop {
+           clear_background(BLACK);
+           map.draw(Vec2::ZERO, vec2(screen_width(), screen_height()));
+           next_frame().await;
+       }
+   }
+   ```
+
+## Limitations
+
+- Map files must be `.json` exported from Tiled.
+- Tilesets must be external JSON tilesets with a single atlas image.
+- Unsupported layer kinds are skipped.
+- Infinite maps are not supported (no chunked `layers[].chunks`).
diff --git a/assets/map.json b/assets/map.json
new file mode 100644
index 0000000..0f440ab
--- /dev/null
+++ b/assets/map.json
@@ -0,0 +1,51 @@
+{ "compressionlevel":-1,
+ "height":20,
+ "infinite":false,
+ "layers":[
+        {
+         "data":[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 1,
+            1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
+         "height":20,
+         "id":1,
+         "name":"Tile Layer 1",
+         "opacity":1,
+         "type":"tilelayer",
+         "visible":true,
+         "width":30,
+         "x":0,
+         "y":0
+        }],
+ "nextlayerid":2,
+ "nextobjectid":1,
+ "orientation":"orthogonal",
+ "renderorder":"right-down",
+ "tiledversion":"1.10.2",
+ "tileheight":32,
+ "tilesets":[
+        {
+         "firstgid":1,
+         "source":"tileset.json"
+        }],
+ "tilewidth":32,
+ "type":"map",
+ "version":"1.10",
+ "width":30
+}
\ No newline at end of file
diff --git a/assets/tileset.json b/assets/tileset.json
new file mode 100644
index 0000000..385ad7d
--- /dev/null
+++ b/assets/tileset.json
@@ -0,0 +1,33 @@
+{
+  "columns": 2,
+  "image": "tileset.png",
+  "imageheight": 64,
+  "imagewidth": 64,
+  "margin": 0,
+  "name": "tileset",
+  "spacing": 0,
+  "tilecount": 4,
+  "tiledversion": "1.10.2",
+  "tileheight": 32,
+  "tiles": [
+    {
+      "id": 0,
+      "type": "Wall"
+    },
+    {
+      "id": 1,
+      "type": "Enemy"
+    },
+    {
+      "id": 2,
+      "type": "Start"
+    },
+    {
+      "id": 3,
+      "type": "Finish"
+    }
+  ],
+  "tilewidth": 32,
+  "type": "tileset",
+  "version": "1.10"
+}
diff --git a/assets/tileset.png b/assets/tileset.png
new file mode 100644
index 0000000..040e31e
Binary files /dev/null and b/assets/tileset.png differ
diff --git a/assets2/coin (1).png b/assets2/coin (1).png
new file mode 100644
index 0000000..e0a1c69
Binary files /dev/null and b/assets2/coin (1).png differ
diff --git a/assets2/coin.json b/assets2/coin.json
new file mode 100644
index 0000000..375c592
--- /dev/null
+++ b/assets2/coin.json
@@ -0,0 +1,14 @@
+{ "columns":1,
+ "image":"coin (1).png",
+ "imageheight":33,
+ "imagewidth":32,
+ "margin":0,
+ "name":"coin",
+ "spacing":0,
+ "tilecount":1,
+ "tiledversion":"1.11.2",
+ "tileheight":32,
+ "tilewidth":32,
+ "type":"tileset",
+ "version":"1.10"
+}
\ No newline at end of file
diff --git a/assets2/coin.png b/assets2/coin.png
new file mode 100644
index 0000000..543d8f2
Binary files /dev/null and b/assets2/coin.png differ
diff --git a/assets2/map.json b/assets2/map.json
new file mode 100644
index 0000000..004956b
--- /dev/null
+++ b/assets2/map.json
@@ -0,0 +1,197 @@
+{ "compressionlevel":-1,
+ "height":20,
+ "infinite":false,
+ "layers":[
+        {
+         "data":[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 1,
+            1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 6, 3, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 6, 6, 6, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
+         "height":20,
+         "id":1,
+         "name":"Tile Layer 1",
+         "opacity":1,
+         "type":"tilelayer",
+         "visible":true,
+         "width":30,
+         "x":0,
+         "y":0
+        }, 
+        {
+         "draworder":"topdown",
+         "id":4,
+         "name":"Object Layer 1",
+         "objects":[
+                {
+                 "height":0,
+                 "id":1,
+                 "name":"Point 1",
+                 "point":true,
+                 "rotation":0,
+                 "type":"",
+                 "visible":true,
+                 "width":0,
+                 "x":286,
+                 "y":271
+                }, 
+                {
+                 "height":64,
+                 "id":43,
+                 "name":"SpawnArea",
+                 "properties":[
+                        {
+                         "name":"spawn",
+                         "type":"bool",
+                         "value":true
+                        }],
+                 "rotation":0,
+                 "type":"Trigger",
+                 "visible":true,
+                 "width":96,
+                 "x":64,
+                 "y":64
+                }, 
+                {
+                 "gid":15,
+                 "height":47,
+                 "id":12,
+                 "name":"",
+                 "rotation":0,
+                 "type":"",
+                 "visible":true,
+                 "width":59,
+                 "x":471,
+                 "y":190
+                }, 
+                {
+                 "gid":15,
+                 "height":89,
+                 "id":13,
+                 "name":"",
+                 "rotation":0,
+                 "type":"",
+                 "visible":true,
+                 "width":87,
+                 "x":538,
+                 "y":392
+                }, 
+                {
+                 "gid":15,
+                 "height":16,
+                 "id":14,
+                 "name":"",
+                 "rotation":0,
+                 "type":"",
+                 "visible":true,
+                 "width":20,
+                 "x":447,
+                 "y":420
+                }],
+         "opacity":1,
+         "type":"objectgroup",
+         "visible":true,
+         "x":0,
+         "y":0
+        }, 
+        {
+         "data":[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1073741834, 2147483658, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 1610612746, 3221225482, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
+         "height":20,
+         "id":3,
+         "name":"Tile Layer 3",
+         "opacity":1,
+         "type":"tilelayer",
+         "visible":true,
+         "width":30,
+         "x":0,
+         "y":0
+        }, 
+        {
+         "data":[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
+         "height":20,
+         "id":2,
+         "name":"Tile Layer 2",
+         "opacity":1,
+         "type":"tilelayer",
+         "visible":true,
+         "width":30,
+         "x":0,
+         "y":0
+        }],
+ "nextlayerid":5,
+ "nextobjectid":15,
+ "orientation":"orthogonal",
+ "renderorder":"right-down",
+ "tiledversion":"1.11.2",
+ "tileheight":32,
+ "tilesets":[
+        {
+         "firstgid":1,
+         "source":"tileset.json"
+        }, 
+        {
+         "firstgid":5,
+         "source":"tileset2.json"
+        }, 
+        {
+         "firstgid":15,
+         "source":"coin.json"
+        }],
+ "tilewidth":32,
+ "type":"map",
+ "version":"1.10",
+ "width":30
+}
\ No newline at end of file
diff --git a/assets2/objects_map.json b/assets2/objects_map.json
new file mode 100644
index 0000000..335ab57
--- /dev/null
+++ b/assets2/objects_map.json
@@ -0,0 +1,125 @@
+{
+  "compressionlevel": -1,
+  "height": 8,
+  "infinite": false,
+  "layers": [
+    {
+      "data": [
+        1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+        1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+        1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+        1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+        1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+        1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+        1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+        1, 1, 1, 1, 1, 1, 1, 1, 1, 1
+      ],
+      "height": 8,
+      "id": 1,
+      "name": "Ground",
+      "opacity": 1,
+      "type": "tilelayer",
+      "visible": true,
+      "width": 10,
+      "x": 0,
+      "y": 0
+    },
+    {
+      "draworder": "topdown",
+      "id": 2,
+      "name": "Objects",
+      "objects": [
+        {
+          "height": 64,
+          "id": 1,
+          "name": "SpawnArea",
+          "rotation": 0,
+          "type": "Trigger",
+          "visible": true,
+          "width": 96,
+          "x": 64,
+          "y": 64,
+          "properties": [
+            {
+              "name": "spawn",
+              "type": "bool",
+              "value": true
+            }
+          ]
+        },
+        {
+          "id": 2,
+          "name": "WayPoint",
+          "point": true,
+          "rotation": 0,
+          "type": "PointOfInterest",
+          "visible": true,
+          "x": 240,
+          "y": 64
+        },
+        {
+          "id": 3,
+          "name": "DangerZone",
+          "polygon": [
+            { "x": 0, "y": 0 },
+            { "x": 60, "y": 10 },
+            { "x": 30, "y": 70 }
+          ],
+          "rotation": 0,
+          "type": "Polygon",
+          "visible": true,
+          "x": 180,
+          "y": 150
+        },
+        {
+          "id": 4,
+          "name": "Path",
+          "polyline": [
+            { "x": 0, "y": 0 },
+            { "x": 45, "y": 30 },
+            { "x": 90, "y": 10 },
+            { "x": 130, "y": 50 }
+          ],
+          "rotation": 0,
+          "type": "Route",
+          "visible": true,
+          "x": 40,
+          "y": 210
+        },
+        {
+          "gid": 1,
+          "height": 32,
+          "id": 5,
+          "name": "TileMarker",
+          "rotation": 0,
+          "type": "TileObject",
+          "visible": true,
+          "width": 32,
+          "x": 290,
+          "y": 110
+        }
+      ],
+      "opacity": 1,
+      "type": "objectgroup",
+      "visible": true,
+      "x": 0,
+      "y": 0
+    }
+  ],
+  "nextlayerid": 3,
+  "nextobjectid": 6,
+  "orientation": "orthogonal",
+  "renderorder": "right-down",
+  "tiledversion": "1.10.2",
+  "tileheight": 32,
+  "tilesets": [
+    {
+      "firstgid": 1,
+      "source": "tileset.json"
+    }
+  ],
+  "tilewidth": 32,
+  "type": "map",
+  "version": "1.10",
+  "width": 10
+}
diff --git a/assets2/pixil-frame-0.png b/assets2/pixil-frame-0.png
new file mode 100644
index 0000000..500c5c4
Binary files /dev/null and b/assets2/pixil-frame-0.png differ
diff --git a/assets2/tilemap.png b/assets2/tilemap.png
new file mode 100644
index 0000000..040e31e
Binary files /dev/null and b/assets2/tilemap.png differ
diff --git a/assets2/tileset.json b/assets2/tileset.json
new file mode 100644
index 0000000..106c2fb
--- /dev/null
+++ b/assets2/tileset.json
@@ -0,0 +1,33 @@
+{
+  "columns": 2,
+  "image": "tilemap.png",
+  "imageheight": 64,
+  "imagewidth": 64,
+  "margin": 0,
+  "name": "tileset",
+  "spacing": 0,
+  "tilecount": 4,
+  "tiledversion": "1.10.2",
+  "tileheight": 32,
+  "tiles": [
+    {
+      "id": 0,
+      "type": "Wall"
+    },
+    {
+      "id": 1,
+      "type": "Enemy"
+    },
+    {
+      "id": 2,
+      "type": "Start"
+    },
+    {
+      "id": 3,
+      "type": "Finish"
+    }
+  ],
+  "tilewidth": 32,
+  "type": "tileset",
+  "version": "1.10"
+}
diff --git a/assets2/tileset2.json b/assets2/tileset2.json
new file mode 100644
index 0000000..6e220d8
--- /dev/null
+++ b/assets2/tileset2.json
@@ -0,0 +1,21 @@
+{
+  "columns": 3,
+  "image": "pixil-frame-0.png",
+  "imageheight": 120,
+  "imagewidth": 120,
+  "margin": 0,
+  "name": "tileset2",
+  "spacing": 0,
+  "tilecount": 9,
+  "tiledversion": "1.10.2",
+  "tileheight": 32,
+  "tiles": [
+    {
+      "id": 0,
+      "type": "grass"
+    }
+  ],
+  "tilewidth": 32,
+  "type": "tileset",
+  "version": "1.10"
+}
diff --git a/examples/basic_map.rs b/examples/basic_map.rs
new file mode 100644
index 0000000..9beed12
--- /dev/null
+++ b/examples/basic_map.rs
@@ -0,0 +1,48 @@
+use macroquad::prelude::*;
+use macroquad_tiled_clone::Map;
+
+// ❶ Override the default 800 × 450 pixels here
+fn window_conf() -> Conf {
+    Conf {
+        window_title: "Basic Map".into(),
+        window_width: 1280, // ← any size you like
+        window_height: 720,
+        ..Default::default()
+    }
+}
+
+#[macroquad::main(window_conf)] // ❷ pass the window config function here
+async fn main() {
+    let mut map = Map::load("assets2/map.json")
+        .await
+        .expect("Failed to load map");
+    let max_frames = std::env::var("MQ_FRAMES")
+        .ok()
+        .and_then(|s| s.parse::<u64>().ok());
+    let mut frame_count = 0u64;
+
+    let screen_size = Vec2::new(screen_width(), screen_height());
+
+    loop {
+        clear_background(BLACK);
+
+        map.draw(Vec2::ZERO, screen_size);
+
+        // Draw the frame rate in the top-left corner
+        draw_text(
+            &format!("FPS: {}", get_fps()),
+            screen_width() - 135.0,
+            55.0,
+            30.0,
+            RED,
+        );
+
+        next_frame().await;
+        frame_count += 1;
+        if let Some(max) = max_frames {
+            if frame_count >= max {
+                break;
+            }
+        }
+    }
+}
diff --git a/examples/objects.rs b/examples/objects.rs
new file mode 100644
index 0000000..a065b3b
--- /dev/null
+++ b/examples/objects.rs
@@ -0,0 +1,45 @@
+use macroquad::prelude::*;
+use macroquad_tiled_clone::Map;
+
+fn window_conf() -> Conf {
+    Conf {
+        window_title: "Objects Example".into(),
+        window_width: 1280,
+        window_height: 720,
+        ..Default::default()
+    }
+}
+
+#[macroquad::main(window_conf)]
+async fn main() {
+    let mut map = Map::load("assets2/map.json")
+        .await
+        .expect("Failed to load map");
+    let max_frames = std::env::var("MQ_FRAMES")
+        .ok()
+        .and_then(|s| s.parse::<u64>().ok());
+    let mut frame_count = 0u64;
+
+    println!("object_layers={}", map.object_layers().len());
+    println!("objects={}", map.objects().count());
+
+    let screen_size = Vec2::new(screen_width(), screen_height());
+
+    loop {
+        clear_background(BLACK);
+        let stamp = map.next_frame_stamp();
+
+        map.draw_visible_rect(Vec2::ZERO, screen_size);
+        map.draw_objects_tiles_with_stamp(Vec2::ZERO, screen_size, stamp);
+        map.draw_objects_debug_with_stamp(Vec2::ZERO, screen_size, stamp);
+
+        draw_text("objects example", 20.0, 30.0, 32.0, WHITE);
+        next_frame().await;
+        frame_count += 1;
+        if let Some(max) = max_frames {
+            if frame_count >= max {
+                break;
+            }
+        }
+    }
+}
diff --git a/src.zip b/src.zip
new file mode 100644
index 0000000..477d184
Binary files /dev/null and b/src.zip differ
diff --git a/src/error.rs b/src/error.rs
deleted file mode 100644
index e69de29..0000000
diff --git a/src/ir_map.rs b/src/ir_map.rs
new file mode 100644
index 0000000..616e774
--- /dev/null
+++ b/src/ir_map.rs
@@ -0,0 +1,142 @@
+// src/ir.rs
+use macroquad::prelude::*;
+use std::collections::HashMap;
+
+#[derive(Clone, Debug, PartialEq)]
+pub enum PropertyValue {
+    Bool(bool),
+    I64(i64),
+    F32(f32),
+    String(String),
+}
+
+#[derive(Clone, Debug, Default, PartialEq)]
+pub struct Properties(HashMap<String, PropertyValue>);
+
+impl Properties {
+    pub fn new() -> Self {
+        Self::default()
+    }
+
+    pub fn insert(&mut self, key: String, value: PropertyValue) {
+        self.0.insert(key, value);
+    }
+
+    pub fn get(&self, key: &str) -> Option<&PropertyValue> {
+        self.0.get(key)
+    }
+
+    pub fn get_bool(&self, key: &str) -> Option<bool> {
+        match self.0.get(key) {
+            Some(PropertyValue::Bool(v)) => Some(*v),
+            _ => None,
+        }
+    }
+
+    pub fn get_i32(&self, key: &str) -> Option<i32> {
+        match self.0.get(key) {
+            Some(PropertyValue::I64(v)) => i32::try_from(*v).ok(),
+            _ => None,
+        }
+    }
+
+    pub fn get_i64(&self, key: &str) -> Option<i64> {
+        match self.0.get(key) {
+            Some(PropertyValue::I64(v)) => Some(*v),
+            _ => None,
+        }
+    }
+
+    pub fn get_f32(&self, key: &str) -> Option<f32> {
+        match self.0.get(key) {
+            Some(PropertyValue::F32(v)) => Some(*v),
+            _ => None,
+        }
+    }
+
+    pub fn get_string(&self, key: &str) -> Option<&str> {
+        match self.0.get(key) {
+            Some(PropertyValue::String(v)) => Some(v.as_str()),
+            _ => None,
+        }
+    }
+}
+
+#[derive(Clone, Debug, PartialEq)]
+pub enum IrObjectShape {
+    Rectangle,
+    Point,
+    Polygon(Vec<Vec2>),
+    Polyline(Vec<Vec2>),
+    Tile { gid: u32 },
+}
+
+#[derive(Clone, Debug, PartialEq)]
+pub struct IrObject {
+    pub id: u32,
+    pub name: String,
+    pub class_name: String,
+    pub x: f32,
+    pub y: f32,
+    pub width: f32,
+    pub height: f32,
+    pub rotation: f32,
+    pub visible: bool,
+    pub shape: IrObjectShape,
+    pub properties: Properties,
+}
+
+#[derive(Clone, Debug, PartialEq)]
+pub struct IrTileMetadata {
+    pub id: u32,
+    pub properties: Properties,
+    pub objects: Vec<IrObject>,
+}
+
+/// Canonical, format-agnostic map.
+pub struct IrMap {
+    pub tile_w: u32,
+    pub tile_h: u32,
+    pub properties: Properties,
+    pub tilesets: Vec<IrTileset>, // must be sorted by first_gid
+    pub layers: Vec<IrLayer>,     // draw order: array order
+}
+
+pub enum IrTileset {
+    /// One image atlas with a regular grid.
+    Atlas {
+        first_gid: u32,
+        image: String,
+        tile_w: u32,
+        tile_h: u32,
+        tilecount: u32,
+        columns: u32,
+        spacing: u32, // 0 if not used
+        margin: u32,  // 0 if not used
+        properties: Properties,
+        tiles: Vec<IrTileMetadata>,
+    },
+    // (later) ImagePerTile { first_gid, tiles: Vec<IrTileImage> },
+}
+
+pub enum IrLayerKind {
+    Tiles {
+        width: usize,
+        height: usize,
+        data: Vec<u32>, // raw GIDs (including flip flags ok)
+    },
+    Objects {
+        objects: Vec<IrObject>,
+    },
+    Unsupported,
+    // (later) Objects { ... }, Image { ... }
+}
+
+pub struct IrLayer {
+    pub name: String,
+    pub visible: bool,
+    pub opacity: f32,
+    pub offset: Vec2, // world offset for this layer
+    pub properties: Properties,
+    pub kind: IrLayerKind,
+}
diff --git a/src/layer.rs b/src/layer.rs
deleted file mode 100644
index e69de29..0000000
diff --git a/src/lib.rs b/src/lib.rs
index b857948..44a33c7 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1,24 +1,13 @@
-mod error;
-mod tiled;
-mod layer;
-
-pub use error::Error;
-pub use tiled::Map;
-pub use layer::Layer;
-
-
-
-pub fn add(left: u64, right: u64) -> u64 {
-    left + right
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[test]
-    fn it_works() {
-        let result = add(2, 2);
-        assert_eq!(result, 4);
-    }
+#[allow(dead_code)]
+mod ir_map;
+mod loader {
+    pub mod json_loader;
 }
+mod map;
+#[allow(dead_code)]
+mod render;
+#[allow(dead_code)]
+mod spatial;
+
+pub use ir_map::{IrObject, IrObjectShape, Properties, PropertyValue};
+pub use map::{LayerId, Map, ObjectLayer};
diff --git a/src/loader/json_loader.rs b/src/loader/json_loader.rs
new file mode 100644
index 0000000..f3e4280
--- /dev/null
+++ b/src/loader/json_loader.rs
@@ -0,0 +1,452 @@
+// src/loader/json.rs
+use crate::ir_map::*;
+use anyhow::Context;
+use macroquad::prelude::*;
+use serde::Deserialize;
+use serde_json::Value as JsonValue;
+use std::path::{Path, PathBuf};
+
+#[derive(Deserialize)]
+struct JsonLayer {
+    #[serde(default)]
+    data: Vec<u32>,
+    #[serde(default)]
+    width: usize,
+    #[serde(default)]
+    height: usize,
+    #[serde(default = "default_true")]
+    visible: bool,
+    #[serde(default = "one")]
+    opacity: f32,
+    #[serde(default)]
+    offsetx: f32,
+    #[serde(default)]
+    offsety: f32,
+    #[serde(default)]
+    name: String,
+    #[serde(rename = "type")]
+    kind: Option<String>, // "tilelayer" expected here
+    #[serde(default)]
+    properties: Vec<JsonProperty>,
+    #[serde(default)]
+    objects: Vec<JsonObject>,
+}
+
+fn default_true() -> bool {
+    true
+}
+fn one() -> f32 {
+    1.0
+}
+
+#[derive(Deserialize)]
+struct JsonTilesetRef {
+    firstgid: u32,
+    source: String,
+}
+
+#[derive(Deserialize)]
+struct JsonMap {
+    tilewidth: u32,
+    tileheight: u32,
+    layers: Vec<JsonLayer>,
+    tilesets: Vec<JsonTilesetRef>,
+    #[serde(default)]
+    properties: Vec<JsonProperty>,
+}
+
+#[derive(Deserialize)]
+struct ExternalTileset {
+    tilewidth: u32,
+    tileheight: u32,
+    tilecount: u32,
+    columns: u32,
+    image: String,
+    #[serde(default)]
+    spacing: u32,
+    #[serde(default)]
+    margin: u32,
+    #[serde(default)]
+    properties: Vec<JsonProperty>,
+    #[serde(default)]
+    tiles: Vec<JsonTile>,
+}
+
+#[derive(Deserialize)]
+struct JsonProperty {
+    name: String,
+    #[serde(default, rename = "type")]
+    kind: Option<String>,
+    value: JsonValue,
+}
+
+#[derive(Deserialize)]
+struct JsonObject {
+    #[serde(default)]
+    id: u32,
+    #[serde(default)]
+    name: String,
+    #[serde(default, rename = "type")]
+    kind: String,
+    #[serde(default)]
+    class: String,
+    #[serde(default)]
+    x: f32,
+    #[serde(default)]
+    y: f32,
+    #[serde(default)]
+    width: f32,
+    #[serde(default)]
+    height: f32,
+    #[serde(default)]
+    rotation: f32,
+    #[serde(default = "default_true")]
+    visible: bool,
+    #[serde(default)]
+    point: bool,
+    #[serde(default)]
+    polygon: Vec<JsonObjectPoint>,
+    #[serde(default)]
+    polyline: Vec<JsonObjectPoint>,
+    #[serde(default)]
+    gid: Option<u32>,
+    #[serde(default)]
+    properties: Vec<JsonProperty>,
+}
+
+#[derive(Deserialize)]
+struct JsonObjectPoint {
+    x: f32,
+    y: f32,
+}
+
+#[derive(Deserialize, Default)]
+struct JsonObjectGroup {
+    #[serde(default)]
+    objects: Vec<JsonObject>,
+}
+
+#[derive(Deserialize)]
+struct JsonTile {
+    id: u32,
+    #[serde(default)]
+    properties: Vec<JsonProperty>,
+    #[serde(default)]
+    objectgroup: JsonObjectGroup,
+}
+
+fn json_property_to_ir(prop: JsonProperty) -> Option<(String, PropertyValue)> {
+    let value = match prop.kind.as_deref() {
+        Some("bool") => prop.value.as_bool().map(PropertyValue::Bool),
+        Some("int") | Some("object") => prop.value.as_i64().map(PropertyValue::I64),
+        Some("float") => prop.value.as_f64().map(|n| PropertyValue::F32(n as f32)),
+        Some("string") | Some("file") | Some("color") | Some("class") => prop
+            .value
+            .as_str()
+            .map(|s| PropertyValue::String(s.to_owned())),
+        _ => {
+            if let Some(v) = prop.value.as_bool() {
+                Some(PropertyValue::Bool(v))
+            } else if let Some(v) = prop.value.as_i64() {
+                Some(PropertyValue::I64(v))
+            } else if let Some(v) = prop.value.as_f64() {
+                Some(PropertyValue::F32(v as f32))
+            } else {
+                prop.value
+                    .as_str()
+                    .map(|s| PropertyValue::String(s.to_owned()))
+            }
+        }
+    }?;
+
+    Some((prop.name, value))
+}
+
+fn properties_from_json(props: Vec<JsonProperty>) -> Properties {
+    let mut out = Properties::new();
+    for p in props {
+        if let Some((name, value)) = json_property_to_ir(p) {
+            out.insert(name, value);
+        }
+    }
+    out
+}
+
+fn object_to_ir(obj: JsonObject) -> IrObject {
+    let shape = if let Some(gid) = obj.gid {
+        IrObjectShape::Tile { gid }
+    } else if obj.point {
+        IrObjectShape::Point
+    } else if !obj.polygon.is_empty() {
+        IrObjectShape::Polygon(obj.polygon.into_iter().map(|p| vec2(p.x, p.y)).collect())
+    } else if !obj.polyline.is_empty() {
+        IrObjectShape::Polyline(obj.polyline.into_iter().map(|p| vec2(p.x, p.y)).collect())
+    } else {
+        IrObjectShape::Rectangle
+    };
+
+    let class_name = if !obj.class.is_empty() {
+        obj.class
+    } else {
+        obj.kind
+    };
+
+    IrObject {
+        id: obj.id,
+        name: obj.name,
+        class_name,
+        x: obj.x,
+        y: obj.y,
+        width: obj.width,
+        height: obj.height,
+        rotation: obj.rotation,
+        visible: obj.visible,
+        shape,
+        properties: properties_from_json(obj.properties),
+    }
+}
+
+pub fn decode_map_file_to_ir(path: &str) -> anyhow::Result<(IrMap, PathBuf)> {
+    let p = Path::new(path);
+    anyhow::ensure!(
+        p.extension().and_then(|e| e.to_str()) == Some("json"),
+        "Map file must be a JSON file: {path}"
+    );
+
+    let txt = std::fs::read_to_string(p).with_context(|| format!("Reading map file {path}"))?;
+    let j: JsonMap =
+        serde_json::from_str(&txt).with_context(|| format!("Parsing map file {path}"))?;
+
+    let map_dir = p
+        .parent()
+        .map(|d| d.to_path_buf())
+        .unwrap_or_else(|| PathBuf::from("./"));
+
+    // Build IR tilesets
+    let mut ir_tilesets = Vec::with_capacity(j.tilesets.len());
+    for ts in &j.tilesets {
+        anyhow::ensure!(
+            ts.source.ends_with(".json"),
+            "External tileset must be JSON: {}",
+            ts.source
+        );
+        let ext_txt = std::fs::read_to_string(map_dir.join(&ts.source))?;
+        let ext: ExternalTileset = serde_json::from_str(&ext_txt)?;
+
+        // (We keep image path relative; Map::from_ir will join with map_dir)
+        ir_tilesets.push(IrTileset::Atlas {
+            first_gid: ts.firstgid,
+            image: ext.image,
+            tile_w: ext.tilewidth,
+            tile_h: ext.tileheight,
+            tilecount: ext.tilecount,
+            columns: ext.columns,
+            spacing: ext.spacing,
+            margin: ext.margin,
+            properties: properties_from_json(ext.properties),
+            tiles: ext
+                .tiles
+                .into_iter()
+                .map(|tile| IrTileMetadata {
+                    id: tile.id,
+                    properties: properties_from_json(tile.properties),
+                    objects: tile
+                        .objectgroup
+                        .objects
+                        .into_iter()
+                        .map(object_to_ir)
+                        .collect(),
+                })
+                .collect(),
+        });
+    }
+
+    // Sort by first_gid to make LUT building trivial
+    ir_tilesets.sort_by_key(|t| match t {
+        IrTileset::Atlas { first_gid, .. } => *first_gid,
+    });
+
+    // Build IR layers
+    let mut ir_layers = Vec::with_capacity(j.layers.len());
+    for l in j.layers {
+        let properties = properties_from_json(l.properties);
+        let layer_kind = match l.kind.as_deref().unwrap_or("tilelayer") {
+            "tilelayer" => IrLayerKind::Tiles {
+                width: l.width,
+                height: l.height,
+                data: l.data,
+            },
+            "objectgroup" => IrLayerKind::Objects {
+                objects: l.objects.into_iter().map(object_to_ir).collect(),
+            },
+            _ => IrLayerKind::Unsupported,
+        };
+        ir_layers.push(IrLayer {
+            name: l.name,
+            visible: l.visible,
+            opacity: l.opacity,
+            offset: vec2(l.offsetx, l.offsety),
+            properties,
+            kind: layer_kind,
+        });
+    }
+
+    Ok((
+        IrMap {
+            tile_w: j.tilewidth,
+            tile_h: j.tileheight,
+            properties: properties_from_json(j.properties),
+            tilesets: ir_tilesets,
+            layers: ir_layers,
+        },
+        map_dir,
+    ))
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use std::fs;
+    use std::time::{SystemTime, UNIX_EPOCH};
+
+    fn temp_dir() -> PathBuf {
+        let nanos = SystemTime::now()
+            .duration_since(UNIX_EPOCH)
+            .expect("clock went backwards")
+            .as_nanos();
+        let dir = std::env::temp_dir().join(format!("mq_tiled_props_{nanos}"));
+        fs::create_dir_all(&dir).expect("failed to create temp dir");
+        dir
+    }
+
+    #[test]
+    fn parses_properties_for_map_layer_object_tileset_and_tile() {
+        let dir = temp_dir();
+        let map_path = dir.join("map.json");
+        let ts_path = dir.join("tileset.json");
+
+        let map_json = r#"{
+          "tilewidth": 16,
+          "tileheight": 16,
+          "properties": [
+            {"name":"is_night","type":"bool","value":true},
+            {"name":"gravity","type":"float","value":9.8},
+            {"name":"theme","type":"string","value":"forest"}
+          ],
+          "layers": [
+            {
+              "type":"tilelayer",
+              "name":"ground",
+              "width":2,
+              "height":2,
+              "data":[1,0,0,0],
+              "properties":[
+                {"name":"is_solid","type":"bool","value":true},
+                {"name":"difficulty","type":"int","value":3}
+              ]
+            },
+            {
+              "type":"objectgroup",
+              "name":"spawns",
+              "objects":[
+                {
+                  "id": 7,
+                  "name":"spawn_1",
+                  "type":"spawn",
+                  "properties":[{"name":"kind","type":"string","value":"player"}]
+                }
+              ],
+              "properties":[{"name":"enabled","type":"bool","value":true}]
+            }
+          ],
+          "tilesets":[{"firstgid":1,"source":"tileset.json"}]
+        }"#;
+
+        let tileset_json = r#"{
+          "tilewidth":16,
+          "tileheight":16,
+          "tilecount":4,
+          "columns":2,
+          "image":"tiles.png",
+          "properties":[{"name":"biome","type":"string","value":"forest"}],
+          "tiles":[
+            {
+              "id":0,
+              "properties":[{"name":"damage","type":"int","value":10}],
+              "objectgroup":{
+                "objects":[
+                  {"id":1,"name":"hitbox","type":"shape","properties":[{"name":"sensor","type":"bool","value":false}]}
+                ]
+              }
+            }
+          ]
+        }"#;
+
+        fs::write(&map_path, map_json).expect("failed to write map");
+        fs::write(&ts_path, tileset_json).expect("failed to write tileset");
+
+        let (ir, _) = decode_map_file_to_ir(map_path.to_str().expect("path utf8")).expect("decode");
+
+        assert_eq!(ir.properties.get_bool("is_night"), Some(true));
+        assert_eq!(ir.properties.get_f32("gravity"), Some(9.8));
+        assert_eq!(ir.properties.get_string("theme"), Some("forest"));
+
+        assert_eq!(ir.layers[0].properties.get_bool("is_solid"), Some(true));
+        assert_eq!(ir.layers[0].properties.get_i32("difficulty"), Some(3));
+
+        match &ir.layers[1].kind {
+            IrLayerKind::Objects { objects } => {
+                assert_eq!(objects.len(), 1);
+                assert_eq!(objects[0].properties.get_string("kind"), Some("player"));
+            }
+            _ => panic!("expected object layer"),
+        }
+
+        match &ir.tilesets[0] {
+            IrTileset::Atlas {
+                properties, tiles, ..
+            } => {
+                assert_eq!(properties.get_string("biome"), Some("forest"));
+                assert_eq!(tiles.len(), 1);
+                assert_eq!(tiles[0].properties.get_i32("damage"), Some(10));
+                assert_eq!(tiles[0].objects.len(), 1);
+                assert_eq!(
+                    tiles[0].objects[0].properties.get_bool("sensor"),
+                    Some(false)
+                );
+            }
+        }
+    }
+
+    #[test]
+    fn keeps_large_int_property_values() {
+        let dir = temp_dir();
+        let map_path = dir.join("map.json");
+        let ts_path = dir.join("tileset.json");
+
+        let map_json = r#"{
+          "tilewidth": 16,
+          "tileheight": 16,
+          "properties": [
+            {"name":"big_id","type":"object","value":5000000000}
+          ],
+          "layers": [],
+          "tilesets":[{"firstgid":1,"source":"tileset.json"}]
+        }"#;
+
+        let tileset_json = r#"{
+          "tilewidth":16,
+          "tileheight":16,
+          "tilecount":1,
+          "columns":1,
+          "image":"tiles.png"
+        }"#;
+
+        fs::write(&map_path, map_json).expect("failed to write map");
+        fs::write(&ts_path, tileset_json).expect("failed to write tileset");
+
+        let (ir, _) = decode_map_file_to_ir(map_path.to_str().expect("path utf8")).expect("decode");
+        assert_eq!(ir.properties.get_i64("big_id"), Some(5_000_000_000));
+        assert_eq!(ir.properties.get_i32("big_id"), None);
+    }
+}
diff --git a/src/loader/mod.rs b/src/loader/mod.rs
new file mode 100644
index 0000000..4bc4814
--- /dev/null
+++ b/src/loader/mod.rs
@@ -0,0 +1,2 @@
+pub mod json_loader;
+pub use json_loader::*;
\ No newline at end of file
diff --git a/src/map.rs b/src/map.rs
new file mode 100644
index 0000000..d6e14a7
--- /dev/null
+++ b/src/map.rs
@@ -0,0 +1,945 @@
+use crate::ir_map::*;
+use crate::loader::json_loader::*;
+use crate::render::*;
+use crate::spatial::{rel, world_to_chunk, GlobalIndex, LayerIdx, TileId, CHUNK_SIZE};
+use anyhow::Context;
+use macroquad::prelude::*;
+use std::collections::HashMap;
+use std::path::Path;
+
+pub type LayerId = u32;
+
+pub struct TilesetInfo {
+    pub first_gid: u32,
+    #[allow(dead_code)]
+    pub tilecount: u32,
+    pub cols: u32,
+    pub tex: Texture2D,
+    pub tile_w: u32,
+    pub tile_h: u32,
+    pub spacing: u32,
+    pub margin: u32,
+}
+
+/// A Tiled object layer parsed from the map.
+///
+/// Stable API: this struct is exposed for inspection/querying (`Map::object_layers`),
+/// not for direct mutation of rendering internals.
+pub struct ObjectLayer {
+    /// Stable layer id matching Tiled layer order.
+    pub id: LayerId,
+    /// Layer name from Tiled.
+    pub name: String,
+    /// Visibility flag from Tiled.
+    pub visible: bool,
+    /// Opacity from Tiled (0.0..=1.0).
+    pub opacity: f32,
+    /// Layer offset in world coordinates.
+    pub offset: Vec2,
+    /// Custom layer properties.
+    pub properties: Properties,
+    /// Parsed objects in this layer.
+    pub objects: Vec<IrObject>,
+    bucket_layer: LayerIdx,
+    // Separate dedupe buffers let tile-object rendering and debug overlay
+    // each draw an object once per frame, using the same frame stamp.
+    seen_stamp_tiles: Vec<u32>,
+    seen_stamp_debug: Vec<u32>,
+}
+
+#[derive(Clone, Copy)]
+struct TileLayerDrawInfo {
+    layer_id: LayerIdx,
+    visible: bool,
+    opacity: f32,
+}
+
+#[derive(Clone, Copy)]
+enum LayerKindInfo {
+    Tiles(usize),
+    Objects(usize),
+    Unsupported,
+}
+
+struct MapRenderer {
+    debug_draw: bool,
+    cull_padding: f32,
+    frame_stamp: u32,
+}
+
+impl MapRenderer {
+    fn new() -> Self {
+        Self::default()
+    }
+
+    fn next_frame_stamp(&mut self, object_layers: &mut [ObjectLayer]) -> u32 {
+        if self.frame_stamp == u32::MAX {
+            for layer in object_layers {
+                layer.seen_stamp_tiles.fill(0);
+                layer.seen_stamp_debug.fill(0);
+            }
+            self.frame_stamp = 1;
+            return 1;
+        }
+
+        self.frame_stamp += 1;
+        self.frame_stamp
+    }
+}
+
+impl Default for MapRenderer {
+    fn default() -> Self {
+        Self {
+            debug_draw: false,
+            cull_padding: CHUNK_SIZE as f32,
+            frame_stamp: 0,
+        }
+    }
+}
+
+fn build_draw_order_and_kind(
+    layers: &[IrLayer],
+) -> (Vec<LayerId>, HashMap<LayerId, LayerKindInfo>) {
+    let mut draw_order = Vec::with_capacity(layers.len());
+    let mut layer_kind_by_id = HashMap::with_capacity(layers.len());
+    let mut tile_layer_idx = 0usize;
+    let mut object_layer_idx = 0usize;
+
+    for (lz, layer) in layers.iter().enumerate() {
+        let stable_id = lz as LayerId;
+        draw_order.push(stable_id);
+        match layer.kind {
+            IrLayerKind::Tiles { .. } => {
+                layer_kind_by_id.insert(stable_id, LayerKindInfo::Tiles(tile_layer_idx));
+                tile_layer_idx += 1;
+            }
+            IrLayerKind::Objects { .. } => {
+                layer_kind_by_id.insert(stable_id, LayerKindInfo::Objects(object_layer_idx));
+                object_layer_idx += 1;
+            }
+            IrLayerKind::Unsupported => {
+                layer_kind_by_id.insert(stable_id, LayerKindInfo::Unsupported);
+            }
+        }
+    }
+
+    (draw_order, layer_kind_by_id)
+}
+
+pub struct Map {
+    index: GlobalIndex,
+    tilesets: Vec<TilesetInfo>,
+    object_layers: Vec<ObjectLayer>,
+    renderer: MapRenderer,
+    gid_lut: Vec<u16>, //lookup table for tile GIDs to tileset indices
+    tile_layers: Vec<TileLayerDrawInfo>,
+    draw_order: Vec<LayerId>,
+    layer_kind_by_id: HashMap<LayerId, LayerKindInfo>,
+}
+
+impl Map {
+    /// Loads a Tiled map JSON file and its external tilesets/textures.
+    ///
+    /// This is the stable entry point for creating a [`Map`].
+    pub async fn load(path: &str) -> anyhow::Result<Self> {
+        let (ir, base) = decode_map_file_to_ir(path)?;
+        Self::from_ir(ir, &base).await
+    }
+
+    pub(crate) async fn from_ir(ir: IrMap, base_dir: &Path) -> anyhow::Result<Self> {
+        let mut tilesets = Vec::new();
+
+        let mut max_gid = 0u32;
+        for t in &ir.tilesets {
+            match t {
+                IrTileset::Atlas {
+                    first_gid,
+                    tilecount,
+                    ..
+                } => {
+                    max_gid = max_gid.max(*first_gid + tilecount - 1);
+                }
+            }
+        }
+
+        let mut gid_lut = vec![u16::MAX; (max_gid + 1) as usize];
+
+        for (i, t) in ir.tilesets.iter().enumerate() {
+            match t {
+                IrTileset::Atlas {
+                    first_gid,
+                    image,
+                    tile_w,
+                    tile_h,
+                    tilecount,
+                    columns,
+                    spacing,
+                    margin,
+                    ..
+                } => {
+                    let img_path = base_dir.join(image);
+                    let img_path_str = img_path.to_str().with_context(|| {
+                        format!(
+                            "Tileset image path is not valid UTF-8: {}",
+                            img_path.display()
+                        )
+                    })?;
+                    let tex = load_texture(img_path_str)
+                        .await
+                        .with_context(|| format!("Loading texture {}", img_path.display()))?;
+                    tex.set_filter(FilterMode::Nearest);
+
+                    tilesets.push(TilesetInfo {
+                        first_gid: *first_gid,
+                        tilecount: *tilecount,
+                        cols: *columns,
+                        tex,
+                        tile_w: *tile_w,
+                        tile_h: *tile_h,
+                        spacing: *spacing,
+                        margin: *margin,
+                    });
+
+                    for gid in *first_gid..(*first_gid + *tilecount) {
+                        gid_lut[gid as usize] = i as u16;
+                    }
+                }
+            }
+        }
+
+        let mut index = GlobalIndex::new();
+        let mut object_layers = Vec::new();
+        let mut tile_layers: Vec<TileLayerDrawInfo> = Vec::new();
+        let (draw_order, layer_kind_by_id) = build_draw_order_and_kind(&ir.layers);
+
+        for (lz, layer) in ir.layers.iter().enumerate() {
+            match &layer.kind {
+                IrLayerKind::Objects { objects } => {
+                    let bucket_layer = lz as LayerIdx;
+                    let layer_idx = object_layers.len();
+                    object_layers.push(ObjectLayer {
+                        id: lz as LayerId,
+                        name: layer.name.clone(),
+                        visible: layer.visible,
+                        opacity: layer.opacity,
+                        offset: layer.offset,
+                        properties: layer.properties.clone(),
+                        objects: objects.clone(),
+                        bucket_layer,
+                        seen_stamp_tiles: vec![0; objects.len()],
+                        seen_stamp_debug: vec![0; objects.len()],
+                    });
+
+                    for (object_idx, obj) in objects.iter().enumerate() {
+                        let world = vec2(obj.x, obj.y) + layer.offset;
+                        let (chunk_min, chunk_max) = Self::object_chunk_span(obj, layer.offset);
+
+                        for cy in chunk_min.y..=chunk_max.y {
+                            for cx in chunk_min.x..=chunk_max.x {
+                                let cc = crate::spatial::ChunkCoord { x: cx, y: cy };
+                                index.insert_object(
+                                    bucket_layer,
+                                    cc,
+                                    crate::spatial::ObjectRec {
+                                        handle: crate::spatial::ObjectHandle(object_idx as u32),
+                                        rel_pos: rel(world),
+                                    },
+                                );
+                            }
+                        }
+                    }
+                    debug_assert!(matches!(
+                        layer_kind_by_id.get(&(lz as LayerId)),
+                        Some(LayerKindInfo::Objects(idx)) if *idx == layer_idx
+                    ));
+                }
+                IrLayerKind::Tiles {
+                    width,
+                    height: _,
+                    data,
+                } => {
+                    let lid = lz as LayerIdx;
+                    let tile_layer_idx = tile_layers.len();
+
+                    let tw = ir.tile_w as f32;
+                    let th = ir.tile_h as f32;
+                    for (idx, gid) in data.iter().enumerate() {
+                        if *gid == 0 {
+                            continue;
+                        }
+                        let col = idx % *width;
+                        let row = idx / *width;
+                        let mut world = vec2(col as f32 * tw, row as f32 * th);
+                        world += layer.offset;
+                        index.add_tile(TileId(*gid), lid, world);
+                    }
+
+                    tile_layers.push(TileLayerDrawInfo {
+                        layer_id: lid,
+                        visible: layer.visible,
+                        opacity: layer.opacity.clamp(0.0, 1.0),
+                    });
+                    debug_assert!(matches!(
+                        layer_kind_by_id.get(&(lz as LayerId)),
+                        Some(LayerKindInfo::Tiles(idx)) if *idx == tile_layer_idx
+                    ));
+                }
+                IrLayerKind::Unsupported => {}
+            }
+        }
+
+        Ok(Self {
+            index,
+            tilesets,
+            object_layers,
+            renderer: MapRenderer::new(),
+            gid_lut,
+            tile_layers,
+            draw_order,
+            layer_kind_by_id,
+        })
+    }
+
+    fn object_aabb_world(obj: &IrObject, layer_offset: Vec2) -> (Vec2, Vec2) {
+        let origin = vec2(obj.x, obj.y) + layer_offset;
+
+        match &obj.shape {
+            IrObjectShape::Rectangle => {
+                let x2 = origin.x + obj.width;
+                let y2 = origin.y + obj.height;
+                (
+                    vec2(origin.x.min(x2), origin.y.min(y2)),
+                    vec2(origin.x.max(x2), origin.y.max(y2)),
+                )
+            }
+            IrObjectShape::Point => (origin - vec2(0.5, 0.5), origin + vec2(0.5, 0.5)),
+            IrObjectShape::Polygon(points) | IrObjectShape::Polyline(points) => {
+                if points.is_empty() {
+                    return (origin - vec2(0.5, 0.5), origin + vec2(0.5, 0.5));
+                }
+
+                let mut min_x = origin.x;
+                let mut min_y = origin.y;
+                let mut max_x = origin.x;
+                let mut max_y = origin.y;
+
+                for p in points {
+                    let wp = origin + *p;
+                    min_x = min_x.min(wp.x);
+                    min_y = min_y.min(wp.y);
+                    max_x = max_x.max(wp.x);
+                    max_y = max_y.max(wp.y);
+                }
+
+                (vec2(min_x, min_y), vec2(max_x, max_y))
+            }
+            IrObjectShape::Tile { .. } => {
+                // Tile objects are drawn at (x, y - h), so AABB must match that.
+                let w = if obj.width > 0.0 { obj.width } else { 1.0 };
+                let h = if obj.height > 0.0 { obj.height } else { 1.0 };
+                (vec2(origin.x, origin.y - h), vec2(origin.x + w, origin.y))
+            }
+        }
+    }
+
+    fn object_chunk_span(
+        obj: &IrObject,
+        layer_offset: Vec2,
+    ) -> (crate::spatial::ChunkCoord, crate::spatial::ChunkCoord) {
+        let (min, max) = Self::object_aabb_world(obj, layer_offset);
+        (world_to_chunk(min), world_to_chunk(max))
+    }
+
+    pub fn next_frame_stamp(&mut self) -> u32 {
+        self.renderer.next_frame_stamp(&mut self.object_layers)
+    }
+
+    pub fn object_layers(&self) -> &[ObjectLayer] {
+        &self.object_layers
+    }
+
+    pub fn objects(&self) -> impl Iterator<Item = &IrObject> {
+        self.object_layers
+            .iter()
+            .flat_map(|layer| layer.objects.iter())
+    }
+
+    #[inline]
+    fn params_for_flips_gid(
+        gid: TileId,
+        tile_w: f32,
+        tile_h: f32,
+    ) -> (f32, bool, bool, Option<Vec2>) {
+        let h = gid.flip_h();
+        let v = gid.flip_v();
+        let d = gid.flip_d();
+
+        let flip_x = h ^ d;
+        let flip_y = v;
+        let pivot = Some(vec2(tile_w / 2.0, tile_h / 2.0));
+
+        let rotation = match (h, v, d) {
+            (false, _, _) => 0.0,
+            (true, false, false) => std::f32::consts::FRAC_PI_2,
+            (true, false, true) => std::f32::consts::FRAC_PI_2,
+            (true, true, false) => std::f32::consts::FRAC_PI_2,
+            (true, true, true) => std::f32::consts::PI,
+        };
+
+        (rotation, flip_x, flip_y, pivot)
+    }
+
+    #[inline]
+    fn params_for_flips(
+        &self,
+        gid: TileId,
+        tile_w: f32,
+        tile_h: f32,
+    ) -> (f32, bool, bool, Option<Vec2>) {
+        Self::params_for_flips_gid(gid, tile_w, tile_h)
+    }
+
+    #[inline]
+    fn ts_for_gid_from<'a>(
+        gid: TileId,
+        gid_lut: &'a [u16],
+        tilesets: &'a [TilesetInfo],
+    ) -> Option<(&'a TilesetInfo, u32)> {
+        let clean = gid.clean() as usize;
+        if clean >= gid_lut.len() {
+            return None;
+        }
+
+        let idx = gid_lut[clean];
+        if idx == u16::MAX {
+            return None;
+        }
+
+        let ts = &tilesets[idx as usize];
+        Some((ts, gid.clean() - ts.first_gid))
+    }
+
+    #[inline]
+    fn ts_for_gid(&self, gid: TileId) -> Option<(&TilesetInfo, u32)> {
+        Self::ts_for_gid_from(gid, &self.gid_lut, &self.tilesets)
+    }
+
+    /// Draws only tile layers inside the visible rectangle.
+    ///
+    /// Stable API for tile-only rendering. Object layers are not drawn here.
+    pub fn draw_visible_rect(&self, view_min: Vec2, view_max: Vec2) {
+        let view = query_visible_rect(&self.index, view_min, view_max);
+        self.draw_chunks(view);
+    }
+
+    /// Draws the full map in configured layer order.
+    ///
+    /// Stable API: draws visible tile layers and tile-objects.
+    /// If debug drawing is enabled, object debug overlays are drawn too.
+    pub fn draw(&mut self, view_min: Vec2, view_max: Vec2) {
+        let coords = self.visible_coords_for_draw(view_min, view_max);
+        let stamp = self.next_frame_stamp();
+        for i in 0..self.draw_order.len() {
+            let layer_id = self.draw_order[i];
+            let Some(kind) = self.layer_kind_by_id.get(&layer_id).copied() else {
+                continue;
+            };
+            match kind {
+                LayerKindInfo::Tiles(tile_layer_idx) => {
+                    self.draw_tile_layer_from_coords(&coords, tile_layer_idx);
+                }
+                LayerKindInfo::Objects(object_layer_idx) => {
+                    self.draw_object_tiles_layer_from_coords(&coords, object_layer_idx, stamp);
+                    if self.renderer.debug_draw {
+                        self.draw_object_debug_layer_from_coords(&coords, object_layer_idx, stamp);
+                    }
+                }
+                LayerKindInfo::Unsupported => {}
+            }
+        }
+    }
+
+    /// Enables/disables object debug overlay drawing used by [`Map::draw`].
+    ///
+    /// Stable API.
+    pub fn set_debug_draw(&mut self, enabled: bool) {
+        self.renderer.debug_draw = enabled;
+    }
+
+    /// Sets extra culling padding in world units around the view rectangle.
+    ///
+    /// Stable API. `0.0` means no extra padding.
+    pub fn set_cull_padding(&mut self, padding: f32) {
+        self.renderer.cull_padding = padding.max(0.0);
+    }
+
+    /// Draws debug shapes for visible object layers.
+    ///
+    /// Stable convenience API: acquires an internal frame stamp automatically.
+    pub fn draw_objects_debug(&mut self, view_min: Vec2, view_max: Vec2) {
+        let stamp = self.next_frame_stamp();
+        self.draw_objects_debug_with_stamp(view_min, view_max, stamp);
+    }
+
+    /// Advanced API: draws debug shapes for visible object layers using a caller-provided stamp.
+    ///
+    /// Use this when you want frame-coherent manual composition (for example:
+    /// tile pass + debug pass in the same frame using one shared stamp).
+    pub fn draw_objects_debug_with_stamp(&mut self, view_min: Vec2, view_max: Vec2, stamp: u32) {
+        let coords = self.visible_coords_for_draw(view_min, view_max);
+        self.draw_object_layers_debug_from_coords(&coords, stamp);
+    }
+
+    /// Draws tile-objects from visible object layers.
+    ///
+    /// Stable convenience API: acquires an internal frame stamp automatically.
+    pub fn draw_objects_tiles(&mut self, view_min: Vec2, view_max: Vec2) {
+        let stamp = self.next_frame_stamp();
+        self.draw_objects_tiles_with_stamp(view_min, view_max, stamp);
+    }
+
+    /// Advanced API: draws tile-objects using a caller-provided stamp.
+    ///
+    /// This exists to support explicit control of object deduplication across
+    /// multiple manual object passes in one frame.
+    pub fn draw_objects_tiles_with_stamp(&mut self, view_min: Vec2, view_max: Vec2, stamp: u32) {
+        let coords = self.visible_coords_for_draw(view_min, view_max);
+        self.draw_object_layers_tiles_from_coords(&coords, stamp);
+    }
+
+    fn draw_chunks(&self, view: LocalView) {
+        for tile_layer_idx in 0..self.tile_layers.len() {
+            self.draw_tile_layer_from_view(&view, tile_layer_idx);
+        }
+    }
+
+    fn draw_tile_layer_from_view(&self, view: &LocalView, tile_layer_idx: usize) {
+        let Some(layer) = self.tile_layers.get(tile_layer_idx) else {
+            return;
+        };
+        if !layer.visible {
+            return;
+        }
+        let tint = Color::new(1.0, 1.0, 1.0, layer.opacity);
+
+        for LocalChunkView { coord: cc, layers } in &view.chunks {
+            if let Some(bucket) = layers.get(&layer.layer_id) {
+                for rec in &bucket.tiles {
+                    let (ts, local) = match self.ts_for_gid(rec.id) {
+                        Some(x) => x,
+                        None => continue,
+                    };
+
+                    let col = local % ts.cols;
+                    let row = local / ts.cols;
+                    let sx = ts.margin + col * (ts.tile_w + ts.spacing);
+                    let sy = ts.margin + row * (ts.tile_h + ts.spacing);
+
+                    let x = ((cc.x * CHUNK_SIZE) as f32 + rec.rel_pos.x).round();
+                    let y = ((cc.y * CHUNK_SIZE) as f32 + rec.rel_pos.y).round();
+
+                    let (rotation, flip_x, flip_y, pivot) =
+                        self.params_for_flips(rec.id, ts.tile_w as f32, ts.tile_h as f32);
+
+                    draw_texture_ex(
+                        &ts.tex,
+                        x,
+                        y,
+                        tint,
+                        DrawTextureParams {
+                            source: Some(Rect::new(
+                                sx as f32,
+                                sy as f32,
+                                ts.tile_w as f32,
+                                ts.tile_h as f32,
+                            )),
+                            rotation,
+                            flip_x,
+                            flip_y,
+                            pivot,
+                            ..Default::default()
+                        },
+                    );
+                }
+            }
+        }
+    }
+
+    fn draw_tile_layer_from_coords(
+        &self,
+        coords: &[crate::spatial::ChunkCoord],
+        tile_layer_idx: usize,
+    ) {
+        let Some(layer) = self.tile_layers.get(tile_layer_idx) else {
+            return;
+        };
+        if !layer.visible {
+            return;
+        }
+        let tint = Color::new(1.0, 1.0, 1.0, layer.opacity);
+
+        Self::for_each_visible_layer_bucket(&self.index, coords, layer.layer_id, |cc, bucket| {
+            for rec in &bucket.tiles {
+                let (ts, local) = match self.ts_for_gid(rec.id) {
+                    Some(x) => x,
+                    None => continue,
+                };
+
+                let col = local % ts.cols;
+                let row = local / ts.cols;
+                let sx = ts.margin + col * (ts.tile_w + ts.spacing);
+                let sy = ts.margin + row * (ts.tile_h + ts.spacing);
+
+                let x = ((cc.x * CHUNK_SIZE) as f32 + rec.rel_pos.x).round();
+                let y = ((cc.y * CHUNK_SIZE) as f32 + rec.rel_pos.y).round();
+
+                let (rotation, flip_x, flip_y, pivot) =
+                    self.params_for_flips(rec.id, ts.tile_w as f32, ts.tile_h as f32);
+
+                draw_texture_ex(
+                    &ts.tex,
+                    x,
+                    y,
+                    tint,
+                    DrawTextureParams {
+                        source: Some(Rect::new(
+                            sx as f32,
+                            sy as f32,
+                            ts.tile_w as f32,
+                            ts.tile_h as f32,
+                        )),
+                        rotation,
+                        flip_x,
+                        flip_y,
+                        pivot,
+                        ..Default::default()
+                    },
+                );
+            }
+        });
+    }
+
+    fn draw_object_layers_debug_from_coords(
+        &mut self,
+        coords: &[crate::spatial::ChunkCoord],
+        stamp: u32,
+    ) {
+        for layer_idx in 0..self.object_layers.len() {
+            self.draw_object_debug_layer_from_coords(coords, layer_idx, stamp);
+        }
+    }
+
+    fn draw_object_layers_tiles_from_coords(
+        &mut self,
+        coords: &[crate::spatial::ChunkCoord],
+        stamp: u32,
+    ) {
+        for layer_idx in 0..self.object_layers.len() {
+            self.draw_object_tiles_layer_from_coords(coords, layer_idx, stamp);
+        }
+    }
+
+    fn draw_object_debug_layer_from_coords(
+        &mut self,
+        coords: &[crate::spatial::ChunkCoord],
+        layer_idx: usize,
+        stamp: u32,
+    ) {
+        let Some(layer) = self.object_layers.get_mut(layer_idx) else {
+            return;
+        };
+        if !layer.visible {
+            return;
+        }
+        let alpha = layer.opacity.clamp(0.0, 1.0);
+        let rect_color = Color::new(YELLOW.r, YELLOW.g, YELLOW.b, alpha);
+        let point_color = Color::new(GREEN.r, GREEN.g, GREEN.b, alpha);
+        let polygon_color = Color::new(SKYBLUE.r, SKYBLUE.g, SKYBLUE.b, alpha);
+        let polyline_color = Color::new(PINK.r, PINK.g, PINK.b, alpha);
+        let tile_color = Color::new(MAGENTA.r, MAGENTA.g, MAGENTA.b, alpha);
+        let bucket_layer = layer.bucket_layer;
+
+        Self::for_each_visible_layer_bucket(
+            &self.index,
+            coords,
+            bucket_layer,
+            |cc, layer_bucket| {
+                let records = &layer_bucket.objects;
+                for rec in records {
+                    let object_idx = rec.handle.0 as usize;
+                    if object_idx >= layer.objects.len() {
+                        debug_assert!(false, "ObjectHandle out of bounds for debug draw");
+                        continue;
+                    }
+                    if object_idx >= layer.seen_stamp_debug.len()
+                        || layer.seen_stamp_debug[object_idx] == stamp
+                    {
+                        continue;
+                    }
+                    layer.seen_stamp_debug[object_idx] = stamp;
+
+                    let Some(obj) = layer.objects.get(object_idx) else {
+                        continue;
+                    };
+                    if !obj.visible {
+                        continue;
+                    }
+
+                    let origin = vec2(
+                        (cc.x * CHUNK_SIZE) as f32 + rec.rel_pos.x,
+                        (cc.y * CHUNK_SIZE) as f32 + rec.rel_pos.y,
+                    );
+
+                    match &obj.shape {
+                        IrObjectShape::Rectangle => {
+                            draw_rectangle_lines(
+                                origin.x,
+                                origin.y,
+                                obj.width.max(2.0),
+                                obj.height.max(2.0),
+                                2.0,
+                                rect_color,
+                            );
+                        }
+                        IrObjectShape::Point => {
+                            draw_circle(origin.x, origin.y, 5.0, point_color);
+                        }
+                        IrObjectShape::Polygon(points) => {
+                            if points.len() < 2 {
+                                continue;
+                            }
+                            for i in 0..points.len() {
+                                let a = origin + points[i];
+                                let b = origin + points[(i + 1) % points.len()];
+                                draw_line(a.x, a.y, b.x, b.y, 2.0, polygon_color);
+                            }
+                        }
+                        IrObjectShape::Polyline(points) => {
+                            for seg in points.windows(2) {
+                                let a = origin + seg[0];
+                                let b = origin + seg[1];
+                                draw_line(a.x, a.y, b.x, b.y, 2.0, polyline_color);
+                            }
+                        }
+                        IrObjectShape::Tile { .. } => {
+                            draw_rectangle_lines(
+                                origin.x,
+                                origin.y - obj.height,
+                                obj.width.max(16.0),
+                                obj.height.max(16.0),
+                                2.0,
+                                tile_color,
+                            );
+                        }
+                    }
+                }
+            },
+        );
+    }
+
+    fn draw_object_tiles_layer_from_coords(
+        &mut self,
+        coords: &[crate::spatial::ChunkCoord],
+        layer_idx: usize,
+        stamp: u32,
+    ) {
+        let gid_lut = &self.gid_lut;
+        let tilesets = &self.tilesets;
+        let Some(layer) = self.object_layers.get_mut(layer_idx) else {
+            return;
+        };
+        if !layer.visible {
+            return;
+        }
+        let tint = Color::new(1.0, 1.0, 1.0, layer.opacity.clamp(0.0, 1.0));
+        let bucket_layer = layer.bucket_layer;
+
+        Self::for_each_visible_layer_bucket(
+            &self.index,
+            coords,
+            bucket_layer,
+            |cc, layer_bucket| {
+                let records = &layer_bucket.objects;
+                for rec in records {
+                    let object_idx = rec.handle.0 as usize;
+                    if object_idx >= layer.objects.len() {
+                        debug_assert!(false, "ObjectHandle out of bounds for tile draw");
+                        continue;
+                    }
+                    if object_idx >= layer.seen_stamp_tiles.len()
+                        || layer.seen_stamp_tiles[object_idx] == stamp
+                    {
+                        continue;
+                    }
+                    layer.seen_stamp_tiles[object_idx] = stamp;
+
+                    let Some(obj) = layer.objects.get(object_idx) else {
+                        continue;
+                    };
+                    if !obj.visible {
+                        continue;
+                    }
+
+                    let IrObjectShape::Tile { gid } = obj.shape else {
+                        continue;
+                    };
+
+                    let origin = vec2(
+                        (cc.x * CHUNK_SIZE) as f32 + rec.rel_pos.x,
+                        (cc.y * CHUNK_SIZE) as f32 + rec.rel_pos.y,
+                    );
+
+                    let gid = TileId(gid);
+                    let Some((ts, local)) = Self::ts_for_gid_from(gid, gid_lut, tilesets) else {
+                        continue;
+                    };
+
+                    let col = local % ts.cols;
+                    let row = local / ts.cols;
+                    let sx = ts.margin + col * (ts.tile_w + ts.spacing);
+                    let sy = ts.margin + row * (ts.tile_h + ts.spacing);
+
+                    let w = if obj.width > 0.0 {
+                        obj.width
+                    } else {
+                        ts.tile_w as f32
+                    };
+                    let h = if obj.height > 0.0 {
+                        obj.height
+                    } else {
+                        ts.tile_h as f32
+                    };
+
+                    let (flag_rotation, flip_x, flip_y, _) = Self::params_for_flips_gid(gid, w, h);
+                    let rotation = obj.rotation.to_radians() + flag_rotation;
+
+                    draw_texture_ex(
+                        &ts.tex,
+                        origin.x,
+                        origin.y - h,
+                        tint,
+                        DrawTextureParams {
+                            source: Some(Rect::new(
+                                sx as f32,
+                                sy as f32,
+                                ts.tile_w as f32,
+                                ts.tile_h as f32,
+                            )),
+                            dest_size: Some(vec2(w, h)),
+                            rotation,
+                            flip_x,
+                            flip_y,
+                            pivot: Some(vec2(0.0, h)),
+                        },
+                    );
+                }
+            },
+        );
+    }
+
+    fn for_each_visible_layer_bucket<F>(
+        index: &GlobalIndex,
+        coords: &[crate::spatial::ChunkCoord],
+        bucket_layer: LayerIdx,
+        mut f: F,
+    ) where
+        F: FnMut(crate::spatial::ChunkCoord, &crate::spatial::LayerBucket),
+    {
+        for cc in coords {
+            let Some(chunk) = index.buckets.get(cc) else {
+                continue;
+            };
+            let Some(bucket) = chunk.layers.get(&bucket_layer) else {
+                continue;
+            };
+            f(*cc, bucket);
+        }
+    }
+
+    fn visible_coords_for_draw(
+        &self,
+        view_min: Vec2,
+        view_max: Vec2,
+    ) -> Vec<crate::spatial::ChunkCoord> {
+        let pad = self.renderer.cull_padding;
+        visible_chunk_coords_rect(
+            vec2(view_min.x - pad, view_min.y - pad),
+            vec2(view_max.x + pad, view_max.y + pad),
+        )
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn object_chunk_span_covers_multi_chunk_rectangles() {
+        let obj = IrObject {
+            id: 1,
+            name: String::new(),
+            class_name: String::new(),
+            x: 250.0,
+            y: 10.0,
+            width: 20.0,
+            height: 20.0,
+            rotation: 0.0,
+            visible: true,
+            shape: IrObjectShape::Rectangle,
+            properties: Properties::default(),
+        };
+
+        let (chunk_min, chunk_max) = Map::object_chunk_span(&obj, Vec2::ZERO);
+        assert_eq!(chunk_min.x, 0);
+        assert_eq!(chunk_max.x, 1);
+        assert_eq!(chunk_min.y, 0);
+        assert_eq!(chunk_max.y, 0);
+    }
+
+    #[test]
+    fn draw_order_matches_tiled_layer_order() {
+        let layers = vec![
+            IrLayer {
+                name: "tiles_a".to_string(),
+                visible: true,
+                opacity: 1.0,
+                offset: Vec2::ZERO,
+                properties: Properties::default(),
+                kind: IrLayerKind::Tiles {
+                    width: 1,
+                    height: 1,
+                    data: vec![0],
+                },
+            },
+            IrLayer {
+                name: "objects_a".to_string(),
+                visible: true,
+                opacity: 1.0,
+                offset: Vec2::ZERO,
+                properties: Properties::default(),
+                kind: IrLayerKind::Objects { objects: vec![] },
+            },
+            IrLayer {
+                name: "tiles_b".to_string(),
+                visible: true,
+                opacity: 1.0,
+                offset: Vec2::ZERO,
+                properties: Properties::default(),
+                kind: IrLayerKind::Tiles {
+                    width: 1,
+                    height: 1,
+                    data: vec![0],
+                },
+            },
+        ];
+
+        let (draw_order, kind_by_id) = build_draw_order_and_kind(&layers);
+        assert_eq!(draw_order, vec![0, 1, 2]);
+        assert!(matches!(kind_by_id.get(&0), Some(LayerKindInfo::Tiles(0))));
+        assert!(matches!(
+            kind_by_id.get(&1),
+            Some(LayerKindInfo::Objects(0))
+        ));
+        assert!(matches!(kind_by_id.get(&2), Some(LayerKindInfo::Tiles(1))));
+    }
+}
diff --git a/src/render/cull.rs b/src/render/cull.rs
new file mode 100644
index 0000000..dedf2c3
--- /dev/null
+++ b/src/render/cull.rs
@@ -0,0 +1,125 @@
+use crate::spatial::{ChunkCoord, GlobalIndex, LayerBucket, LayerIdx, CHUNK_SIZE};
+use macroquad::prelude::*;
+use std::collections::HashMap;
+
+const CULL_MARGIN_CHUNKS: i32 = 1;
+
+pub struct LocalChunkView<'g> {
+    pub coord: ChunkCoord,
+    pub layers: &'g HashMap<LayerIdx, LayerBucket>,
+}
+pub struct LocalView<'g> {
+    pub chunks: Vec<LocalChunkView<'g>>,
+}
+
+pub fn visible_chunk_coords_rect(view_min: Vec2, view_max: Vec2) -> Vec<ChunkCoord> {
+    let mut cx_min = (view_min.x as i32).div_euclid(CHUNK_SIZE);
+    let mut cy_min = (view_min.y as i32).div_euclid(CHUNK_SIZE);
+    let mut cx_max = (view_max.x as i32).div_euclid(CHUNK_SIZE);
+    let mut cy_max = (view_max.y as i32).div_euclid(CHUNK_SIZE);
+
+    if cx_min > cx_max {
+        std::mem::swap(&mut cx_min, &mut cx_max);
+    }
+    if cy_min > cy_max {
+        std::mem::swap(&mut cy_min, &mut cy_max);
+    }
+
+    let mut coords = Vec::new();
+    for cy in cy_min..=cy_max {
+        for cx in cx_min..=cx_max {
+            coords.push(ChunkCoord { x: cx, y: cy });
+        }
+    }
+    coords
+}
+
+pub fn query_visible<'g>(g: &'g GlobalIndex, cam: &Camera2D) -> LocalView<'g> {
+    let (viewport_width, viewport_height) = match cam.viewport {
+        Some((_, _, w, h)) => (w as f32, h as f32),
+        None => (screen_width(), screen_height()), // Fall back to screen dimensions
+    };
+
+    let half_w = viewport_width / cam.zoom.x / 2.0;
+    let half_h = viewport_height / cam.zoom.y / 2.0;
+    let cam_min = cam.target - Vec2::new(half_w, half_h);
+    let cam_max = cam.target + Vec2::new(half_w, half_h);
+
+    //pad by one chunk
+    let pad = CHUNK_SIZE as f32;
+    let min = vec2(cam_min.x - pad, cam_min.y - pad);
+    let max = vec2(cam_max.x + pad, cam_max.y + pad);
+
+    let cx_min = (min.x as i32).div_euclid(CHUNK_SIZE);
+    let cy_min = (min.y as i32).div_euclid(CHUNK_SIZE);
+    let cx_max = (max.x as i32).div_euclid(CHUNK_SIZE);
+    let cy_max = (max.y as i32).div_euclid(CHUNK_SIZE);
+
+    let mut chunks = Vec::new();
+    for (&coord, bucket) in &g.buckets {
+        if coord.x >= cx_min && coord.x <= cx_max && coord.y >= cy_min && coord.y <= cy_max {
+            chunks.push(LocalChunkView {
+                coord,
+                layers: &bucket.layers,
+            })
+        }
+    }
+    chunks.sort_by_key(|c| (c.coord.y, c.coord.x));
+
+    LocalView { chunks }
+}
+
+pub fn query_visible_rect<'g>(g: &'g GlobalIndex, view_min: Vec2, view_max: Vec2) -> LocalView<'g> {
+    let mut cx_min = (view_min.x as i32).div_euclid(CHUNK_SIZE);
+    let mut cy_min = (view_min.y as i32).div_euclid(CHUNK_SIZE);
+    let mut cx_max = (view_max.x as i32).div_euclid(CHUNK_SIZE);
+    let mut cy_max = (view_max.y as i32).div_euclid(CHUNK_SIZE);
+
+    //pad by one chunk
+    if cx_min > cx_max {
+        std::mem::swap(&mut cx_min, &mut cx_max);
+    }
+    if cy_min > cy_max {
+        std::mem::swap(&mut cy_min, &mut cy_max);
+    }
+
+    cx_min -= CULL_MARGIN_CHUNKS;
+    cy_min -= CULL_MARGIN_CHUNKS;
+    cx_max += CULL_MARGIN_CHUNKS;
+    cy_max += CULL_MARGIN_CHUNKS;
+
+    let mut chunks = Vec::new();
+    for (&coord, bucket) in &g.buckets {
+        if coord.x >= cx_min && coord.x <= cx_max && coord.y >= cy_min && coord.y <= cy_max {
+            chunks.push(LocalChunkView {
+                coord,
+                layers: &bucket.layers,
+            })
+        }
+    }
+    chunks.sort_by_key(|c| (c.coord.y, c.coord.x));
+
+    LocalView { chunks }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::spatial::TileId;
+
+    #[test]
+    fn query_visible_rect_returns_chunks_in_stable_order() {
+        let mut index = GlobalIndex::new();
+        index.add_tile(TileId(1), 0, vec2(520.0, 520.0)); // (2,2)
+        index.add_tile(TileId(1), 0, vec2(0.0, 0.0)); // (0,0)
+        index.add_tile(TileId(1), 0, vec2(260.0, 0.0)); // (1,0)
+        index.add_tile(TileId(1), 0, vec2(0.0, 260.0)); // (0,1)
+
+        let view = query_visible_rect(&index, vec2(0.0, 0.0), vec2(800.0, 800.0));
+        let coords: Vec<ChunkCoord> = view.chunks.iter().map(|c| c.coord).collect();
+
+        assert!(coords
+            .windows(2)
+            .all(|w| (w[0].y, w[0].x) <= (w[1].y, w[1].x)));
+    }
+}
diff --git a/src/render/mod.rs b/src/render/mod.rs
new file mode 100644
index 0000000..4993544
--- /dev/null
+++ b/src/render/mod.rs
@@ -0,0 +1,2 @@
+pub mod cull;
+pub use cull::*;
diff --git a/src/spatial/index.rs b/src/spatial/index.rs
new file mode 100644
index 0000000..7eebf37
--- /dev/null
+++ b/src/spatial/index.rs
@@ -0,0 +1,169 @@
+use macroquad::prelude::*;
+use std::collections::HashMap;
+
+pub const CHUNK_SIZE: i32 = 256;
+
+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
+pub struct TileId(pub u32);
+
+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
+pub struct TileHandle(pub u32);
+
+pub type LayerIdx = u16;
+
+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
+pub struct ChunkCoord {
+    pub x: i32,
+    pub y: i32,
+}
+
+pub const FLIP_H: u32 = 0x8000_0000; // bit 31
+pub const FLIP_V: u32 = 0x4000_0000; // bit 30
+pub const FLIP_D: u32 = 0x2000_0000; // bit 29
+pub const GID_MASK: u32 = 0x1FFF_FFFF; // keep lower 29 bits (bit 28 is free)
+
+impl TileId {
+    #[inline]
+    pub fn raw(self) -> u32 {
+        self.0
+    }
+    #[inline]
+    pub fn clean(self) -> u32 {
+        self.0 & GID_MASK
+    }
+    #[inline]
+    pub fn flip_h(self) -> bool {
+        (self.0 & FLIP_H) != 0
+    }
+    #[inline]
+    pub fn flip_v(self) -> bool {
+        (self.0 & FLIP_V) != 0
+    }
+    #[inline]
+    pub fn flip_d(self) -> bool {
+        (self.0 & FLIP_D) != 0
+    }
+}
+
+#[inline]
+pub fn world_to_chunk(p: Vec2) -> ChunkCoord {
+    ChunkCoord {
+        x: (p.x as i32).div_euclid(CHUNK_SIZE),
+        y: (p.y as i32).div_euclid(CHUNK_SIZE),
+    }
+}
+
+#[inline]
+pub fn rel(p: Vec2) -> Vec2 {
+    vec2(
+        (p.x as i32).rem_euclid(CHUNK_SIZE) as f32,
+        (p.y as i32).rem_euclid(CHUNK_SIZE) as f32,
+    )
+}
+
+#[derive(Debug, Clone)]
+pub struct TileRec {
+    pub handle: TileHandle,
+    pub id: TileId,
+    pub rel_pos: Vec2,
+}
+
+#[derive(Debug, Clone)]
+pub struct ObjectRec {
+    pub handle: ObjectHandle,
+    pub rel_pos: Vec2,
+}
+
+#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
+pub struct ObjectHandle(pub u32);
+
+#[derive(Debug, Clone, Default)]
+pub struct LayerBucket {
+    pub tiles: Vec<TileRec>,
+    pub objects: Vec<ObjectRec>,
+}
+
+pub struct GlobalChunk {
+    pub layers: HashMap<LayerIdx, LayerBucket>,
+}
+
+impl GlobalChunk {
+    pub fn new() -> Self {
+        GlobalChunk {
+            layers: HashMap::new(),
+        }
+    }
+}
+
+impl Default for GlobalChunk {
+    fn default() -> Self {
+        Self::new()
+    }
+}
+
+pub struct TileLoc {
+    pub chunk: ChunkCoord,
+    pub layer: LayerIdx,
+    pub index: usize,
+}
+
+pub struct GlobalIndex {
+    pub buckets: HashMap<ChunkCoord, GlobalChunk>,
+    pub handles: Vec<Option<TileLoc>>,
+    next_handle: u32,
+}
+
+impl GlobalIndex {
+    pub fn new() -> Self {
+        GlobalIndex {
+            buckets: HashMap::new(),
+            handles: Vec::new(),
+            next_handle: 0,
+        }
+    }
+
+    fn alloc_handle(&mut self) -> TileHandle {
+        let h = TileHandle(self.next_handle);
+        self.next_handle += 1;
+        self.handles.push(None);
+        h
+    }
+}
+
+impl Default for GlobalIndex {
+    fn default() -> Self {
+        Self::new()
+    }
+}
+
+impl GlobalIndex {
+    pub fn add_tile(&mut self, id: TileId, layer: LayerIdx, world: Vec2) -> TileHandle {
+        let cc = world_to_chunk(world);
+        let handle = self.alloc_handle();
+        let bucket = self.buckets.entry(cc).or_default();
+        let vec = &mut bucket.layers.entry(layer).or_default().tiles;
+
+        let idx = vec.len();
+        vec.push(TileRec {
+            handle,
+            id,
+            rel_pos: rel(world),
+        });
+        self.handles[handle.0 as usize] = Some(TileLoc {
+            chunk: cc,
+            layer,
+            index: idx,
+        });
+        handle
+    }
+
+    pub fn insert_object(&mut self, layer: LayerIdx, chunk: ChunkCoord, object_rec: ObjectRec) {
+        let bucket = self.buckets.entry(chunk).or_default();
+        bucket
+            .layers
+            .entry(layer)
+            .or_default()
+            .objects
+            .push(object_rec);
+    }
+}
diff --git a/src/spatial/mod.rs b/src/spatial/mod.rs
new file mode 100644
index 0000000..f7a4d01
--- /dev/null
+++ b/src/spatial/mod.rs
@@ -0,0 +1,3 @@
+// spatial/mod.rs
+pub mod index;
+pub use index::*;
diff --git a/src/tiled.rs b/src/tiled.rs
deleted file mode 100644
index e69de29..0000000
diff --git a/ticket_diff.txt b/ticket_diff.txt
new file mode 100644
index 0000000..c567c20
--- /dev/null
+++ b/ticket_diff.txt
@@ -0,0 +1,3069 @@
+diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
+index 71e0d94..b56b5c0 100644
+--- a/.github/workflows/ci.yml
++++ b/.github/workflows/ci.yml
+@@ -6,8 +6,12 @@ jobs:
+   build:
+     runs-on: ubuntu-latest
+     steps:
+-      - uses: actions/checkout@v3
++      - uses: actions/checkout@v4
+       - uses: actions-rs/toolchain@v1
+         with:
+           toolchain: stable
+-      - run: cargo test --verbose
++          components: rustfmt, clippy
++      - run: cargo fmt -- --check
++      - run: cargo clippy -- -D warnings
++      - run: cargo test
++      - run: cargo check --examples
+diff --git a/examples/basic_map.rs b/examples/basic_map.rs
+index d69606d..9beed12 100644
+--- a/examples/basic_map.rs
++++ b/examples/basic_map.rs
+@@ -1,5 +1,5 @@
+ use macroquad::prelude::*;
+-use macroquad_tiled_clone::map::Map;
++use macroquad_tiled_clone::Map;
+ 
+ // ❶ Override the default 800 × 450 pixels here
+ fn window_conf() -> Conf {
+diff --git a/examples/objects.rs b/examples/objects.rs
+index 1424354..a065b3b 100644
+--- a/examples/objects.rs
++++ b/examples/objects.rs
+@@ -1,5 +1,5 @@
+ use macroquad::prelude::*;
+-use macroquad_tiled_clone::map::Map;
++use macroquad_tiled_clone::Map;
+ 
+ fn window_conf() -> Conf {
+     Conf {
+diff --git a/src.zip b/src.zip
+index c33c0f4..477d184 100644
+Binary files a/src.zip and b/src.zip differ
+diff --git a/src/lib.rs b/src/lib.rs
+index 1a35e90..44a33c7 100644
+--- a/src/lib.rs
++++ b/src/lib.rs
+@@ -1,10 +1,13 @@
+-pub mod ir_map;
+-pub mod map;
+-pub mod render;
+-pub mod spatial;
+-pub mod loader {
++#[allow(dead_code)]
++mod ir_map;
++mod loader {
+     pub mod json_loader;
+ }
++mod map;
++#[allow(dead_code)]
++mod render;
++#[allow(dead_code)]
++mod spatial;
+ 
+-pub use map::Map;
+-pub use spatial::{GlobalIndex, LayerIdx, TileHandle, TileId};
++pub use ir_map::{IrObject, IrObjectShape, Properties, PropertyValue};
++pub use map::{LayerId, Map, ObjectLayer};
+diff --git a/src/map.rs b/src/map.rs
+index 01dc296..d6e14a7 100644
+--- a/src/map.rs
++++ b/src/map.rs
+@@ -1,10 +1,7 @@
+ use crate::ir_map::*;
+ use crate::loader::json_loader::*;
+ use crate::render::*;
+-use crate::{
+-    spatial::{rel, world_to_chunk, CHUNK_SIZE},
+-    GlobalIndex, LayerIdx, TileId,
+-};
++use crate::spatial::{rel, world_to_chunk, GlobalIndex, LayerIdx, TileId, CHUNK_SIZE};
+ use anyhow::Context;
+ use macroquad::prelude::*;
+ use std::collections::HashMap;
+@@ -14,6 +11,7 @@ pub type LayerId = u32;
+ 
+ pub struct TilesetInfo {
+     pub first_gid: u32,
++    #[allow(dead_code)]
+     pub tilecount: u32,
+     pub cols: u32,
+     pub tex: Texture2D,
+@@ -23,13 +21,24 @@ pub struct TilesetInfo {
+     pub margin: u32,
+ }
+ 
++/// A Tiled object layer parsed from the map.
++///
++/// Stable API: this struct is exposed for inspection/querying (`Map::object_layers`),
++/// not for direct mutation of rendering internals.
+ pub struct ObjectLayer {
++    /// Stable layer id matching Tiled layer order.
+     pub id: LayerId,
++    /// Layer name from Tiled.
+     pub name: String,
++    /// Visibility flag from Tiled.
+     pub visible: bool,
++    /// Opacity from Tiled (0.0..=1.0).
+     pub opacity: f32,
++    /// Layer offset in world coordinates.
+     pub offset: Vec2,
++    /// Custom layer properties.
+     pub properties: Properties,
++    /// Parsed objects in this layer.
+     pub objects: Vec<IrObject>,
+     bucket_layer: LayerIdx,
+     // Separate dedupe buffers let tile-object rendering and debug overlay
+@@ -88,26 +97,56 @@ impl Default for MapRenderer {
+     }
+ }
+ 
++fn build_draw_order_and_kind(
++    layers: &[IrLayer],
++) -> (Vec<LayerId>, HashMap<LayerId, LayerKindInfo>) {
++    let mut draw_order = Vec::with_capacity(layers.len());
++    let mut layer_kind_by_id = HashMap::with_capacity(layers.len());
++    let mut tile_layer_idx = 0usize;
++    let mut object_layer_idx = 0usize;
++
++    for (lz, layer) in layers.iter().enumerate() {
++        let stable_id = lz as LayerId;
++        draw_order.push(stable_id);
++        match layer.kind {
++            IrLayerKind::Tiles { .. } => {
++                layer_kind_by_id.insert(stable_id, LayerKindInfo::Tiles(tile_layer_idx));
++                tile_layer_idx += 1;
++            }
++            IrLayerKind::Objects { .. } => {
++                layer_kind_by_id.insert(stable_id, LayerKindInfo::Objects(object_layer_idx));
++                object_layer_idx += 1;
++            }
++            IrLayerKind::Unsupported => {
++                layer_kind_by_id.insert(stable_id, LayerKindInfo::Unsupported);
++            }
++        }
++    }
++
++    (draw_order, layer_kind_by_id)
++}
++
+ pub struct Map {
+-    pub index: GlobalIndex,
+-    pub tilesets: Vec<TilesetInfo>,
++    index: GlobalIndex,
++    tilesets: Vec<TilesetInfo>,
+     object_layers: Vec<ObjectLayer>,
+     renderer: MapRenderer,
+     gid_lut: Vec<u16>, //lookup table for tile GIDs to tileset indices
+     tile_layers: Vec<TileLayerDrawInfo>,
+     draw_order: Vec<LayerId>,
+     layer_kind_by_id: HashMap<LayerId, LayerKindInfo>,
+-    pub tile_w: u32,
+-    pub tile_h: u32,
+ }
+ 
+ impl Map {
++    /// Loads a Tiled map JSON file and its external tilesets/textures.
++    ///
++    /// This is the stable entry point for creating a [`Map`].
+     pub async fn load(path: &str) -> anyhow::Result<Self> {
+         let (ir, base) = decode_map_file_to_ir(path)?;
+         Self::from_ir(ir, &base).await
+     }
+ 
+-    pub async fn from_ir(ir: IrMap, base_dir: &Path) -> anyhow::Result<Self> {
++    pub(crate) async fn from_ir(ir: IrMap, base_dir: &Path) -> anyhow::Result<Self> {
+         let mut tilesets = Vec::new();
+ 
+         let mut max_gid = 0u32;
+@@ -139,9 +178,15 @@ impl Map {
+                     ..
+                 } => {
+                     let img_path = base_dir.join(image);
+-                    let tex = load_texture(img_path.to_str().unwrap())
++                    let img_path_str = img_path.to_str().with_context(|| {
++                        format!(
++                            "Tileset image path is not valid UTF-8: {}",
++                            img_path.display()
++                        )
++                    })?;
++                    let tex = load_texture(img_path_str)
+                         .await
+-                        .with_context(|| format!("Loading texture {}", image))?;
++                        .with_context(|| format!("Loading texture {}", img_path.display()))?;
+                     tex.set_filter(FilterMode::Nearest);
+ 
+                     tilesets.push(TilesetInfo {
+@@ -165,19 +210,15 @@ impl Map {
+         let mut index = GlobalIndex::new();
+         let mut object_layers = Vec::new();
+         let mut tile_layers: Vec<TileLayerDrawInfo> = Vec::new();
+-        let mut draw_order: Vec<LayerId> = Vec::new();
+-        let mut layer_kind_by_id: HashMap<LayerId, LayerKindInfo> = HashMap::new();
++        let (draw_order, layer_kind_by_id) = build_draw_order_and_kind(&ir.layers);
+ 
+         for (lz, layer) in ir.layers.iter().enumerate() {
+-            let stable_id = lz as LayerId;
+-            draw_order.push(stable_id);
+-
+             match &layer.kind {
+                 IrLayerKind::Objects { objects } => {
+-                    let layer_idx = object_layers.len();
+                     let bucket_layer = lz as LayerIdx;
++                    let layer_idx = object_layers.len();
+                     object_layers.push(ObjectLayer {
+-                        id: stable_id,
++                        id: lz as LayerId,
+                         name: layer.name.clone(),
+                         visible: layer.visible,
+                         opacity: layer.opacity,
+@@ -191,9 +232,7 @@ impl Map {
+ 
+                     for (object_idx, obj) in objects.iter().enumerate() {
+                         let world = vec2(obj.x, obj.y) + layer.offset;
+-                        let (min, max) = Self::object_aabb_world(obj, layer.offset);
+-                        let chunk_min = world_to_chunk(min);
+-                        let chunk_max = world_to_chunk(max);
++                        let (chunk_min, chunk_max) = Self::object_chunk_span(obj, layer.offset);
+ 
+                         for cy in chunk_min.y..=chunk_max.y {
+                             for cx in chunk_min.x..=chunk_max.x {
+@@ -209,16 +248,18 @@ impl Map {
+                             }
+                         }
+                     }
+-
+-                    layer_kind_by_id.insert(stable_id, LayerKindInfo::Objects(layer_idx));
++                    debug_assert!(matches!(
++                        layer_kind_by_id.get(&(lz as LayerId)),
++                        Some(LayerKindInfo::Objects(idx)) if *idx == layer_idx
++                    ));
+                 }
+                 IrLayerKind::Tiles {
+                     width,
+                     height: _,
+                     data,
+                 } => {
+-                    let tile_layer_idx = tile_layers.len();
+                     let lid = lz as LayerIdx;
++                    let tile_layer_idx = tile_layers.len();
+ 
+                     let tw = ir.tile_w as f32;
+                     let th = ir.tile_h as f32;
+@@ -238,11 +279,12 @@ impl Map {
+                         visible: layer.visible,
+                         opacity: layer.opacity.clamp(0.0, 1.0),
+                     });
+-                    layer_kind_by_id.insert(stable_id, LayerKindInfo::Tiles(tile_layer_idx));
+-                }
+-                IrLayerKind::Unsupported => {
+-                    layer_kind_by_id.insert(stable_id, LayerKindInfo::Unsupported);
++                    debug_assert!(matches!(
++                        layer_kind_by_id.get(&(lz as LayerId)),
++                        Some(LayerKindInfo::Tiles(idx)) if *idx == tile_layer_idx
++                    ));
+                 }
++                IrLayerKind::Unsupported => {}
+             }
+         }
+ 
+@@ -255,8 +297,6 @@ impl Map {
+             tile_layers,
+             draw_order,
+             layer_kind_by_id,
+-            tile_w: ir.tile_w,
+-            tile_h: ir.tile_h,
+         })
+     }
+ 
+@@ -302,6 +342,14 @@ impl Map {
+         }
+     }
+ 
++    fn object_chunk_span(
++        obj: &IrObject,
++        layer_offset: Vec2,
++    ) -> (crate::spatial::ChunkCoord, crate::spatial::ChunkCoord) {
++        let (min, max) = Self::object_aabb_world(obj, layer_offset);
++        (world_to_chunk(min), world_to_chunk(max))
++    }
++
+     pub fn next_frame_stamp(&mut self) -> u32 {
+         self.renderer.next_frame_stamp(&mut self.object_layers)
+     }
+@@ -376,11 +424,18 @@ impl Map {
+         Self::ts_for_gid_from(gid, &self.gid_lut, &self.tilesets)
+     }
+ 
++    /// Draws only tile layers inside the visible rectangle.
++    ///
++    /// Stable API for tile-only rendering. Object layers are not drawn here.
+     pub fn draw_visible_rect(&self, view_min: Vec2, view_max: Vec2) {
+         let view = query_visible_rect(&self.index, view_min, view_max);
+         self.draw_chunks(view);
+     }
+ 
++    /// Draws the full map in configured layer order.
++    ///
++    /// Stable API: draws visible tile layers and tile-objects.
++    /// If debug drawing is enabled, object debug overlays are drawn too.
+     pub fn draw(&mut self, view_min: Vec2, view_max: Vec2) {
+         let coords = self.visible_coords_for_draw(view_min, view_max);
+         let stamp = self.next_frame_stamp();
+@@ -404,29 +459,49 @@ impl Map {
+         }
+     }
+ 
++    /// Enables/disables object debug overlay drawing used by [`Map::draw`].
++    ///
++    /// Stable API.
+     pub fn set_debug_draw(&mut self, enabled: bool) {
+         self.renderer.debug_draw = enabled;
+     }
+ 
++    /// Sets extra culling padding in world units around the view rectangle.
++    ///
++    /// Stable API. `0.0` means no extra padding.
+     pub fn set_cull_padding(&mut self, padding: f32) {
+         self.renderer.cull_padding = padding.max(0.0);
+     }
+ 
++    /// Draws debug shapes for visible object layers.
++    ///
++    /// Stable convenience API: acquires an internal frame stamp automatically.
+     pub fn draw_objects_debug(&mut self, view_min: Vec2, view_max: Vec2) {
+         let stamp = self.next_frame_stamp();
+         self.draw_objects_debug_with_stamp(view_min, view_max, stamp);
+     }
+ 
++    /// Advanced API: draws debug shapes for visible object layers using a caller-provided stamp.
++    ///
++    /// Use this when you want frame-coherent manual composition (for example:
++    /// tile pass + debug pass in the same frame using one shared stamp).
+     pub fn draw_objects_debug_with_stamp(&mut self, view_min: Vec2, view_max: Vec2, stamp: u32) {
+         let coords = self.visible_coords_for_draw(view_min, view_max);
+         self.draw_object_layers_debug_from_coords(&coords, stamp);
+     }
+ 
++    /// Draws tile-objects from visible object layers.
++    ///
++    /// Stable convenience API: acquires an internal frame stamp automatically.
+     pub fn draw_objects_tiles(&mut self, view_min: Vec2, view_max: Vec2) {
+         let stamp = self.next_frame_stamp();
+         self.draw_objects_tiles_with_stamp(view_min, view_max, stamp);
+     }
+ 
++    /// Advanced API: draws tile-objects using a caller-provided stamp.
++    ///
++    /// This exists to support explicit control of object deduplication across
++    /// multiple manual object passes in one frame.
+     pub fn draw_objects_tiles_with_stamp(&mut self, view_min: Vec2, view_max: Vec2, stamp: u32) {
+         let coords = self.visible_coords_for_draw(view_min, view_max);
+         self.draw_object_layers_tiles_from_coords(&coords, stamp);
+@@ -793,3 +868,78 @@ impl Map {
+         )
+     }
+ }
++
++#[cfg(test)]
++mod tests {
++    use super::*;
++
++    #[test]
++    fn object_chunk_span_covers_multi_chunk_rectangles() {
++        let obj = IrObject {
++            id: 1,
++            name: String::new(),
++            class_name: String::new(),
++            x: 250.0,
++            y: 10.0,
++            width: 20.0,
++            height: 20.0,
++            rotation: 0.0,
++            visible: true,
++            shape: IrObjectShape::Rectangle,
++            properties: Properties::default(),
++        };
++
++        let (chunk_min, chunk_max) = Map::object_chunk_span(&obj, Vec2::ZERO);
++        assert_eq!(chunk_min.x, 0);
++        assert_eq!(chunk_max.x, 1);
++        assert_eq!(chunk_min.y, 0);
++        assert_eq!(chunk_max.y, 0);
++    }
++
++    #[test]
++    fn draw_order_matches_tiled_layer_order() {
++        let layers = vec![
++            IrLayer {
++                name: "tiles_a".to_string(),
++                visible: true,
++                opacity: 1.0,
++                offset: Vec2::ZERO,
++                properties: Properties::default(),
++                kind: IrLayerKind::Tiles {
++                    width: 1,
++                    height: 1,
++                    data: vec![0],
++                },
++            },
++            IrLayer {
++                name: "objects_a".to_string(),
++                visible: true,
++                opacity: 1.0,
++                offset: Vec2::ZERO,
++                properties: Properties::default(),
++                kind: IrLayerKind::Objects { objects: vec![] },
++            },
++            IrLayer {
++                name: "tiles_b".to_string(),
++                visible: true,
++                opacity: 1.0,
++                offset: Vec2::ZERO,
++                properties: Properties::default(),
++                kind: IrLayerKind::Tiles {
++                    width: 1,
++                    height: 1,
++                    data: vec![0],
++                },
++            },
++        ];
++
++        let (draw_order, kind_by_id) = build_draw_order_and_kind(&layers);
++        assert_eq!(draw_order, vec![0, 1, 2]);
++        assert!(matches!(kind_by_id.get(&0), Some(LayerKindInfo::Tiles(0))));
++        assert!(matches!(
++            kind_by_id.get(&1),
++            Some(LayerKindInfo::Objects(0))
++        ));
++        assert!(matches!(kind_by_id.get(&2), Some(LayerKindInfo::Tiles(1))));
++    }
++}
+diff --git a/src/render/cull.rs b/src/render/cull.rs
+index 82ef9f3..dedf2c3 100644
+--- a/src/render/cull.rs
++++ b/src/render/cull.rs
+@@ -1,7 +1,4 @@
+-use crate::{
+-    spatial::{ChunkCoord, LayerBucket, CHUNK_SIZE},
+-    GlobalIndex, LayerIdx,
+-};
++use crate::spatial::{ChunkCoord, GlobalIndex, LayerBucket, LayerIdx, CHUNK_SIZE};
+ use macroquad::prelude::*;
+ use std::collections::HashMap;
+ 
+diff --git a/ticket_diff.txt b/ticket_diff.txt
+index 715078d..4df7a58 100644
+--- a/ticket_diff.txt
++++ b/ticket_diff.txt
+@@ -1,2608 +0,0 @@
+-diff --git a/examples/objects.rs b/examples/objects.rs
+-index f286bc0..1424354 100644
+---- a/examples/objects.rs
+-+++ b/examples/objects.rs
+-@@ -30,8 +30,8 @@ async fn main() {
+-         let stamp = map.next_frame_stamp();
+- 
+-         map.draw_visible_rect(Vec2::ZERO, screen_size);
+--        map.draw_objects_tiles(Vec2::ZERO, screen_size, stamp);
+--        map.draw_objects_debug(Vec2::ZERO, screen_size, stamp);
+-+        map.draw_objects_tiles_with_stamp(Vec2::ZERO, screen_size, stamp);
+-+        map.draw_objects_debug_with_stamp(Vec2::ZERO, screen_size, stamp);
+- 
+-         draw_text("objects example", 20.0, 30.0, 32.0, WHITE);
+-         next_frame().await;
+-diff --git a/src/map.rs b/src/map.rs
+-index 0ae2584..01dc296 100644
+---- a/src/map.rs
+-+++ b/src/map.rs
+-@@ -412,12 +412,22 @@ impl Map {
+-         self.renderer.cull_padding = padding.max(0.0);
+-     }
+- 
+--    pub fn draw_objects_debug(&mut self, view_min: Vec2, view_max: Vec2, stamp: u32) {
+-+    pub fn draw_objects_debug(&mut self, view_min: Vec2, view_max: Vec2) {
+-+        let stamp = self.next_frame_stamp();
+-+        self.draw_objects_debug_with_stamp(view_min, view_max, stamp);
+-+    }
+-+
+-+    pub fn draw_objects_debug_with_stamp(&mut self, view_min: Vec2, view_max: Vec2, stamp: u32) {
+-         let coords = self.visible_coords_for_draw(view_min, view_max);
+-         self.draw_object_layers_debug_from_coords(&coords, stamp);
+-     }
+- 
+--    pub fn draw_objects_tiles(&mut self, view_min: Vec2, view_max: Vec2, stamp: u32) {
+-+    pub fn draw_objects_tiles(&mut self, view_min: Vec2, view_max: Vec2) {
+-+        let stamp = self.next_frame_stamp();
+-+        self.draw_objects_tiles_with_stamp(view_min, view_max, stamp);
+-+    }
+-+
+-+    pub fn draw_objects_tiles_with_stamp(&mut self, view_min: Vec2, view_max: Vec2, stamp: u32) {
+-         let coords = self.visible_coords_for_draw(view_min, view_max);
+-         self.draw_object_layers_tiles_from_coords(&coords, stamp);
+-     }
+-diff --git a/ticket_diff.txt b/ticket_diff.txt
+-index 76a902f..e69de29 100644
+---- a/ticket_diff.txt
+-+++ b/ticket_diff.txt
+-@@ -1,2559 +0,0 @@
+--diff --git a/examples/objects.rs b/examples/objects.rs
+--index 79e658f..f286bc0 100644
+----- a/examples/objects.rs
+--+++ b/examples/objects.rs
+--@@ -27,10 +27,11 @@ async fn main() {
+-- 
+--     loop {
+--         clear_background(BLACK);
+--+        let stamp = map.next_frame_stamp();
+-- 
+--         map.draw_visible_rect(Vec2::ZERO, screen_size);
+---        map.draw_objects_tiles(Vec2::ZERO, screen_size);
+---        map.draw_objects_debug(Vec2::ZERO, screen_size);
+--+        map.draw_objects_tiles(Vec2::ZERO, screen_size, stamp);
+--+        map.draw_objects_debug(Vec2::ZERO, screen_size, stamp);
+-- 
+--         draw_text("objects example", 20.0, 30.0, 32.0, WHITE);
+--         next_frame().await;
+--diff --git a/src/map.rs b/src/map.rs
+--index aac5601..5fc5309 100644
+----- a/src/map.rs
+--+++ b/src/map.rs
+--@@ -52,13 +52,47 @@ enum LayerKindInfo {
+--     Unsupported,
+-- }
+-- 
+--+struct MapRenderer {
+--+    debug_draw: bool,
+--+    cull_padding: f32,
+--+    frame_stamp: u32,
+--+}
+--+
+--+impl MapRenderer {
+--+    fn new() -> Self {
+--+        Self::default()
+--+    }
+--+
+--+    fn next_frame_stamp(&mut self, object_layers: &mut [ObjectLayer]) -> u32 {
+--+        if self.frame_stamp == u32::MAX {
+--+            for layer in object_layers {
+--+                layer.seen_stamp_tiles.fill(0);
+--+                layer.seen_stamp_debug.fill(0);
+--+            }
+--+            self.frame_stamp = 1;
+--+            return 1;
+--+        }
+--+
+--+        self.frame_stamp += 1;
+--+        self.frame_stamp
+--+    }
+--+}
+--+
+--+impl Default for MapRenderer {
+--+    fn default() -> Self {
+--+        Self {
+--+            debug_draw: false,
+--+            cull_padding: CHUNK_SIZE as f32,
+--+            frame_stamp: 0,
+--+        }
+--+    }
+--+}
+--+
+-- pub struct Map {
+--     pub index: GlobalIndex,
+--     pub tilesets: Vec<TilesetInfo>,
+--     object_layers: Vec<ObjectLayer>,
+---    debug_draw: bool,
+---    frame_stamp: u32,
+---    cull_padding: f32,
+--+    renderer: MapRenderer,
+--     gid_lut: Vec<u16>, //lookup table for tile GIDs to tileset indices
+--     tile_layers: Vec<TileLayerDrawInfo>,
+--     draw_order: Vec<LayerId>,
+--@@ -168,7 +202,7 @@ impl Map {
+--                                     bucket_layer,
+--                                     cc,
+--                                     crate::spatial::ObjectRec {
+---                                        id: object_idx as u32,
+--+                                        handle: crate::spatial::ObjectHandle(object_idx as u32),
+--                                         rel_pos: rel(world),
+--                                     },
+--                                 );
+--@@ -216,9 +250,7 @@ impl Map {
+--             index,
+--             tilesets,
+--             object_layers,
+---            debug_draw: false,
+---            frame_stamp: 0,
+---            cull_padding: CHUNK_SIZE as f32,
+--+            renderer: MapRenderer::new(),
+--             gid_lut,
+--             tile_layers,
+--             draw_order,
+--@@ -270,17 +302,8 @@ impl Map {
+--         }
+--     }
+-- 
+---    fn next_frame_stamp(&mut self) -> u32 {
+---        if self.frame_stamp == u32::MAX {
+---            for layer in &mut self.object_layers {
+---                layer.seen_stamp_tiles.fill(0);
+---                layer.seen_stamp_debug.fill(0);
+---            }
+---            self.frame_stamp = 1;
+---            return 1;
+---        }
+---        self.frame_stamp += 1;
+---        self.frame_stamp
+--+    pub fn next_frame_stamp(&mut self) -> u32 {
+--+        self.renderer.next_frame_stamp(&mut self.object_layers)
+--     }
+-- 
+--     pub fn object_layers(&self) -> &[ObjectLayer] {
+--@@ -372,7 +395,7 @@ impl Map {
+--                 }
+--                 LayerKindInfo::Objects(object_layer_idx) => {
+--                     self.draw_object_tiles_layer_from_coords(&coords, object_layer_idx, stamp);
+---                    if self.debug_draw {
+--+                    if self.renderer.debug_draw {
+--                         self.draw_object_debug_layer_from_coords(&coords, object_layer_idx, stamp);
+--                     }
+--                 }
+--@@ -382,21 +405,21 @@ impl Map {
+--     }
+-- 
+--     pub fn set_debug_draw(&mut self, enabled: bool) {
+---        self.debug_draw = enabled;
+--+        self.renderer.debug_draw = enabled;
+--     }
+-- 
+--     pub fn set_cull_padding(&mut self, padding: f32) {
+---        self.cull_padding = padding.max(0.0);
+--+        self.renderer.cull_padding = padding.max(0.0);
+--     }
+-- 
+---    pub fn draw_objects_debug(&mut self, view_min: Vec2, view_max: Vec2) {
+--+    pub fn draw_objects_debug(&mut self, view_min: Vec2, view_max: Vec2, stamp: u32) {
+--         let coords = self.visible_coords_for_draw(view_min, view_max);
+---        self.draw_chunk_objects_debug_coords(&coords);
+--+        self.draw_object_layers_debug_from_coords(&coords, stamp);
+--     }
+-- 
+---    pub fn draw_objects_tiles(&mut self, view_min: Vec2, view_max: Vec2) {
+--+    pub fn draw_objects_tiles(&mut self, view_min: Vec2, view_max: Vec2, stamp: u32) {
+--         let coords = self.visible_coords_for_draw(view_min, view_max);
+---        self.draw_chunk_objects_tiles_coords(&coords);
+--+        self.draw_object_layers_tiles_from_coords(&coords, stamp);
+--     }
+-- 
+--     fn draw_chunks(&self, view: LocalView) {
+--@@ -470,13 +493,7 @@ impl Map {
+--         }
+--         let tint = Color::new(1.0, 1.0, 1.0, layer.opacity);
+-- 
+---        for cc in coords {
+---            let Some(global_chunk) = self.index.buckets.get(cc) else {
+---                continue;
+---            };
+---            let Some(bucket) = global_chunk.layers.get(&layer.layer_id) else {
+---                continue;
+---            };
+--+        Self::for_each_visible_layer_bucket(&self.index, coords, layer.layer_id, |cc, bucket| {
+--             for rec in &bucket.tiles {
+--                 let (ts, local) = match self.ts_for_gid(rec.id) {
+--                     Some(x) => x,
+--@@ -514,18 +531,24 @@ impl Map {
+--                     },
+--                 );
+--             }
+---        }
+--+        });
+--     }
+-- 
+---    fn draw_chunk_objects_debug_coords(&mut self, coords: &[crate::spatial::ChunkCoord]) {
+---        let stamp = self.next_frame_stamp();
+--+    fn draw_object_layers_debug_from_coords(
+--+        &mut self,
+--+        coords: &[crate::spatial::ChunkCoord],
+--+        stamp: u32,
+--+    ) {
+--         for layer_idx in 0..self.object_layers.len() {
+--             self.draw_object_debug_layer_from_coords(coords, layer_idx, stamp);
+--         }
+--     }
+-- 
+---    fn draw_chunk_objects_tiles_coords(&mut self, coords: &[crate::spatial::ChunkCoord]) {
+---        let stamp = self.next_frame_stamp();
+--+    fn draw_object_layers_tiles_from_coords(
+--+        &mut self,
+--+        coords: &[crate::spatial::ChunkCoord],
+--+        stamp: u32,
+--+    ) {
+--         for layer_idx in 0..self.object_layers.len() {
+--             self.draw_object_tiles_layer_from_coords(coords, layer_idx, stamp);
+--         }
+--@@ -549,18 +572,16 @@ impl Map {
+--         let polygon_color = Color::new(SKYBLUE.r, SKYBLUE.g, SKYBLUE.b, alpha);
+--         let polyline_color = Color::new(PINK.r, PINK.g, PINK.b, alpha);
+--         let tile_color = Color::new(MAGENTA.r, MAGENTA.g, MAGENTA.b, alpha);
+--+        let bucket_layer = layer.bucket_layer;
+-- 
+---        for cc in coords {
+---            let Some(global_chunk) = self.index.buckets.get(cc) else {
+---                continue;
+---            };
+---            let Some(layer_bucket) = global_chunk.layers.get(&layer.bucket_layer) else {
+---                continue;
+---            };
+--+        Self::for_each_visible_layer_bucket(&self.index, coords, bucket_layer, |cc, layer_bucket| {
+--             let records = &layer_bucket.objects;
+---
+--             for rec in records {
+---                let object_idx = rec.id as usize;
+--+                let object_idx = rec.handle.0 as usize;
+--+                if object_idx >= layer.objects.len() {
+--+                    debug_assert!(false, "ObjectHandle out of bounds for debug draw");
+--+                    continue;
+--+                }
+--                 if object_idx >= layer.seen_stamp_debug.len()
+--                     || layer.seen_stamp_debug[object_idx] == stamp
+--                 {
+--@@ -623,7 +644,7 @@ impl Map {
+--                     }
+--                 }
+--             }
+---        }
+--+        });
+--     }
+-- 
+--     fn draw_object_tiles_layer_from_coords(
+--@@ -641,18 +662,16 @@ impl Map {
+--             return;
+--         }
+--         let tint = Color::new(1.0, 1.0, 1.0, layer.opacity.clamp(0.0, 1.0));
+--+        let bucket_layer = layer.bucket_layer;
+-- 
+---        for cc in coords {
+---            let Some(global_chunk) = self.index.buckets.get(cc) else {
+---                continue;
+---            };
+---            let Some(layer_bucket) = global_chunk.layers.get(&layer.bucket_layer) else {
+---                continue;
+---            };
+--+        Self::for_each_visible_layer_bucket(&self.index, coords, bucket_layer, |cc, layer_bucket| {
+--             let records = &layer_bucket.objects;
+---
+--             for rec in records {
+---                let object_idx = rec.id as usize;
+--+                let object_idx = rec.handle.0 as usize;
+--+                if object_idx >= layer.objects.len() {
+--+                    debug_assert!(false, "ObjectHandle out of bounds for tile draw");
+--+                    continue;
+--+                }
+--                 if object_idx >= layer.seen_stamp_tiles.len()
+--                     || layer.seen_stamp_tiles[object_idx] == stamp
+--                 {
+--@@ -717,10 +736,28 @@ impl Map {
+--                         flip_x,
+--                         flip_y,
+--                         pivot: Some(vec2(0.0, h)),
+---                        ..Default::default()
+--                     },
+--                 );
+--             }
+--+        });
+--+    }
+--+
+--+    fn for_each_visible_layer_bucket<F>(
+--+        index: &GlobalIndex,
+--+        coords: &[crate::spatial::ChunkCoord],
+--+        bucket_layer: LayerIdx,
+--+        mut f: F,
+--+    ) where
+--+        F: FnMut(crate::spatial::ChunkCoord, &crate::spatial::LayerBucket),
+--+    {
+--+        for cc in coords {
+--+            let Some(chunk) = index.buckets.get(cc) else {
+--+                continue;
+--+            };
+--+            let Some(bucket) = chunk.layers.get(&bucket_layer) else {
+--+                continue;
+--+            };
+--+            f(*cc, bucket);
+--         }
+--     }
+-- 
+--@@ -729,7 +766,7 @@ impl Map {
+--         view_min: Vec2,
+--         view_max: Vec2,
+--     ) -> Vec<crate::spatial::ChunkCoord> {
+---        let pad = self.cull_padding;
+--+        let pad = self.renderer.cull_padding;
+--         visible_chunk_coords_rect(
+--             vec2(view_min.x - pad, view_min.y - pad),
+--             vec2(view_max.x + pad, view_max.y + pad),
+--diff --git a/src/spatial/index.rs b/src/spatial/index.rs
+--index 94179b7..7eebf37 100644
+----- a/src/spatial/index.rs
+--+++ b/src/spatial/index.rs
+--@@ -70,10 +70,13 @@ pub struct TileRec {
+-- 
+-- #[derive(Debug, Clone)]
+-- pub struct ObjectRec {
+---    pub id: u32,
+--+    pub handle: ObjectHandle,
+--     pub rel_pos: Vec2,
+-- }
+-- 
+--+#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
+--+pub struct ObjectHandle(pub u32);
+--+
+-- #[derive(Debug, Clone, Default)]
+-- pub struct LayerBucket {
+--     pub tiles: Vec<TileRec>,
+--@@ -92,6 +95,12 @@ impl GlobalChunk {
+--     }
+-- }
+-- 
+--+impl Default for GlobalChunk {
+--+    fn default() -> Self {
+--+        Self::new()
+--+    }
+--+}
+--+
+-- pub struct TileLoc {
+--     pub chunk: ChunkCoord,
+--     pub layer: LayerIdx,
+--@@ -121,11 +130,17 @@ impl GlobalIndex {
+--     }
+-- }
+-- 
+--+impl Default for GlobalIndex {
+--+    fn default() -> Self {
+--+        Self::new()
+--+    }
+--+}
+--+
+-- impl GlobalIndex {
+--     pub fn add_tile(&mut self, id: TileId, layer: LayerIdx, world: Vec2) -> TileHandle {
+--         let cc = world_to_chunk(world);
+--         let handle = self.alloc_handle();
+---        let bucket = self.buckets.entry(cc).or_insert_with(GlobalChunk::new);
+--+        let bucket = self.buckets.entry(cc).or_default();
+--         let vec = &mut bucket.layers.entry(layer).or_default().tiles;
+-- 
+--         let idx = vec.len();
+--@@ -143,7 +158,7 @@ impl GlobalIndex {
+--     }
+-- 
+--     pub fn insert_object(&mut self, layer: LayerIdx, chunk: ChunkCoord, object_rec: ObjectRec) {
+---        let bucket = self.buckets.entry(chunk).or_insert_with(GlobalChunk::new);
+--+        let bucket = self.buckets.entry(chunk).or_default();
+--         bucket
+--             .layers
+--             .entry(layer)
+--diff --git a/ticket_diff.txt b/ticket_diff.txt
+--index 392f3bd..ba0a50a 100644
+----- a/ticket_diff.txt
+--+++ b/ticket_diff.txt
+--@@ -1,2199 +0,0 @@
+---diff --git a/examples/basic_map.rs b/examples/basic_map.rs
+---index 41a1859..d69606d 100644
+------ a/examples/basic_map.rs
+---+++ b/examples/basic_map.rs
+---@@ -16,6 +16,10 @@ async fn main() {
+---     let mut map = Map::load("assets2/map.json")
+---         .await
+---         .expect("Failed to load map");
+---+    let max_frames = std::env::var("MQ_FRAMES")
+---+        .ok()
+---+        .and_then(|s| s.parse::<u64>().ok());
+---+    let mut frame_count = 0u64;
+--- 
+---     let screen_size = Vec2::new(screen_width(), screen_height());
+--- 
+---@@ -34,5 +38,11 @@ async fn main() {
+---         );
+--- 
+---         next_frame().await;
+---+        frame_count += 1;
+---+        if let Some(max) = max_frames {
+---+            if frame_count >= max {
+---+                break;
+---+            }
+---+        }
+---     }
+--- }
+---diff --git a/examples/objects.rs b/examples/objects.rs
+---index 9002986..79e658f 100644
+------ a/examples/objects.rs
+---+++ b/examples/objects.rs
+---@@ -15,6 +15,10 @@ async fn main() {
+---     let mut map = Map::load("assets2/map.json")
+---         .await
+---         .expect("Failed to load map");
+---+    let max_frames = std::env::var("MQ_FRAMES")
+---+        .ok()
+---+        .and_then(|s| s.parse::<u64>().ok());
+---+    let mut frame_count = 0u64;
+--- 
+---     println!("object_layers={}", map.object_layers().len());
+---     println!("objects={}", map.objects().count());
+---@@ -30,5 +34,11 @@ async fn main() {
+--- 
+---         draw_text("objects example", 20.0, 30.0, 32.0, WHITE);
+---         next_frame().await;
+---+        frame_count += 1;
+---+        if let Some(max) = max_frames {
+---+            if frame_count >= max {
+---+                break;
+---+            }
+---+        }
+---     }
+--- }
+---diff --git a/src/map.rs b/src/map.rs
+---index ffed3ce..aac5601 100644
+------ a/src/map.rs
+---+++ b/src/map.rs
+---@@ -32,6 +32,8 @@ pub struct ObjectLayer {
+---     pub properties: Properties,
+---     pub objects: Vec<IrObject>,
+---     bucket_layer: LayerIdx,
+---+    // Separate dedupe buffers let tile-object rendering and debug overlay
+---+    // each draw an object once per frame, using the same frame stamp.
+---     seen_stamp_tiles: Vec<u32>,
+---     seen_stamp_debug: Vec<u32>,
+--- }
+---@@ -56,6 +58,7 @@ pub struct Map {
+---     object_layers: Vec<ObjectLayer>,
+---     debug_draw: bool,
+---     frame_stamp: u32,
+---+    cull_padding: f32,
+---     gid_lut: Vec<u16>, //lookup table for tile GIDs to tileset indices
+---     tile_layers: Vec<TileLayerDrawInfo>,
+---     draw_order: Vec<LayerId>,
+---@@ -215,6 +218,7 @@ impl Map {
+---             object_layers,
+---             debug_draw: false,
+---             frame_stamp: 0,
+---+            cull_padding: CHUNK_SIZE as f32,
+---             gid_lut,
+---             tile_layers,
+---             draw_order,
+---@@ -266,17 +270,17 @@ impl Map {
+---         }
+---     }
+--- 
+----    fn next_stamp(frame_stamp: &mut u32, object_layers: &mut [ObjectLayer]) -> u32 {
+----        if *frame_stamp == u32::MAX {
+----            for layer in object_layers {
+---+    fn next_frame_stamp(&mut self) -> u32 {
+---+        if self.frame_stamp == u32::MAX {
+---+            for layer in &mut self.object_layers {
+---                 layer.seen_stamp_tiles.fill(0);
+---                 layer.seen_stamp_debug.fill(0);
+---             }
+----            *frame_stamp = 1;
+---+            self.frame_stamp = 1;
+---             return 1;
+---         }
+----        *frame_stamp += 1;
+----        *frame_stamp
+---+        self.frame_stamp += 1;
+---+        self.frame_stamp
+---     }
+--- 
+---     pub fn object_layers(&self) -> &[ObjectLayer] {
+---@@ -355,10 +359,11 @@ impl Map {
+---     }
+--- 
+---     pub fn draw(&mut self, view_min: Vec2, view_max: Vec2) {
+----        let coords = Self::visible_coords_for_draw(view_min, view_max);
+----        let draw_order = self.draw_order.clone();
+----        for layer_id in &draw_order {
+----            let Some(kind) = self.layer_kind_by_id.get(layer_id).copied() else {
+---+        let coords = self.visible_coords_for_draw(view_min, view_max);
+---+        let stamp = self.next_frame_stamp();
+---+        for i in 0..self.draw_order.len() {
+---+            let layer_id = self.draw_order[i];
+---+            let Some(kind) = self.layer_kind_by_id.get(&layer_id).copied() else {
+---                 continue;
+---             };
+---             match kind {
+---@@ -366,11 +371,8 @@ impl Map {
+---                     self.draw_tile_layer_from_coords(&coords, tile_layer_idx);
+---                 }
+---                 LayerKindInfo::Objects(object_layer_idx) => {
+----                    let stamp = Self::next_stamp(&mut self.frame_stamp, &mut self.object_layers);
+---                     self.draw_object_tiles_layer_from_coords(&coords, object_layer_idx, stamp);
+---                     if self.debug_draw {
+----                        let stamp =
+----                            Self::next_stamp(&mut self.frame_stamp, &mut self.object_layers);
+---                         self.draw_object_debug_layer_from_coords(&coords, object_layer_idx, stamp);
+---                     }
+---                 }
+---@@ -383,13 +385,17 @@ impl Map {
+---         self.debug_draw = enabled;
+---     }
+--- 
+---+    pub fn set_cull_padding(&mut self, padding: f32) {
+---+        self.cull_padding = padding.max(0.0);
+---+    }
+---+
+---     pub fn draw_objects_debug(&mut self, view_min: Vec2, view_max: Vec2) {
+----        let coords = Self::visible_coords_for_draw(view_min, view_max);
+---+        let coords = self.visible_coords_for_draw(view_min, view_max);
+---         self.draw_chunk_objects_debug_coords(&coords);
+---     }
+--- 
+---     pub fn draw_objects_tiles(&mut self, view_min: Vec2, view_max: Vec2) {
+----        let coords = Self::visible_coords_for_draw(view_min, view_max);
+---+        let coords = self.visible_coords_for_draw(view_min, view_max);
+---         self.draw_chunk_objects_tiles_coords(&coords);
+---     }
+--- 
+---@@ -512,14 +518,14 @@ impl Map {
+---     }
+--- 
+---     fn draw_chunk_objects_debug_coords(&mut self, coords: &[crate::spatial::ChunkCoord]) {
+----        let stamp = Self::next_stamp(&mut self.frame_stamp, &mut self.object_layers);
+---+        let stamp = self.next_frame_stamp();
+---         for layer_idx in 0..self.object_layers.len() {
+---             self.draw_object_debug_layer_from_coords(coords, layer_idx, stamp);
+---         }
+---     }
+--- 
+---     fn draw_chunk_objects_tiles_coords(&mut self, coords: &[crate::spatial::ChunkCoord]) {
+----        let stamp = Self::next_stamp(&mut self.frame_stamp, &mut self.object_layers);
+---+        let stamp = self.next_frame_stamp();
+---         for layer_idx in 0..self.object_layers.len() {
+---             self.draw_object_tiles_layer_from_coords(coords, layer_idx, stamp);
+---         }
+---@@ -718,8 +724,12 @@ impl Map {
+---         }
+---     }
+--- 
+----    fn visible_coords_for_draw(view_min: Vec2, view_max: Vec2) -> Vec<crate::spatial::ChunkCoord> {
+----        let pad = CHUNK_SIZE as f32;
+---+    fn visible_coords_for_draw(
+---+        &self,
+---+        view_min: Vec2,
+---+        view_max: Vec2,
+---+    ) -> Vec<crate::spatial::ChunkCoord> {
+---+        let pad = self.cull_padding;
+---         visible_chunk_coords_rect(
+---             vec2(view_min.x - pad, view_min.y - pad),
+---             vec2(view_max.x + pad, view_max.y + pad),
+---diff --git a/ticket_diff.txt b/ticket_diff.txt
+---index 64f832e..e69de29 100644
+------ a/ticket_diff.txt
+---+++ b/ticket_diff.txt
+---@@ -1,2007 +0,0 @@
+----diff --git a/README.md b/README.md
+----index 0d8eb47..75aec17 100644
+------- a/README.md
+----+++ b/README.md
+----@@ -5,23 +5,31 @@ Minimal Tiled JSON loader and renderer for Macroquad.
+---- ## Supports
+---- 
+---- - Tiled JSON maps (orthogonal) with external tilesets (`source` .json)
+------ Tile layers with `data` arrays
+----+- Tile layers (finite) with `data` arrays
+---- - Object layers (`objectgroup`)
+----+- Tile objects (`gid`)
+---- - Multiple tilesets (firstgid mapping)
+---- - Per-layer offsets
+---- - Properties on map/layer/object/tileset/tile
+---- - Tile flip/rotation flags from Tiled GIDs
+---- - Rendering via `draw_texture_ex` with nearest filtering
+---- - Universal draw API: `map.draw(view_min, view_max)` (tiles + tile-objects)
+----+- Optional debug outlines via `set_debug_draw(true)`
+---- 
+---- ## Not yet
+---- 
+------ Inline tilesets
+------ Image layers
+---- - Infinite maps (chunked layers)
+----+- Image layers
+----+- Group layers
+----+- Embedded tilesets
+----+- Base64/compressed layer data
+---- - Isometric or hex maps
+---- - Tile animations
+------ Layer visibility/opacity in rendering
+----+
+----+## Rendering API
+----+
+----+- `draw(view_min, view_max)`: draws tiles + tile-objects, and draws debug outlines when `debug_draw` is enabled.
+----+- `draw_visible_rect(view_min, view_max)`: draws tiles only (advanced/manual flow).
+---- 
+---- ## Quickstart
+---- 
+----@@ -58,4 +66,3 @@ Minimal Tiled JSON loader and renderer for Macroquad.
+---- - Tilesets must be external JSON tilesets with a single atlas image.
+---- - Unsupported layer kinds are skipped.
+---- - Infinite maps are not supported (no chunked `layers[].chunks`).
+------ Layer `visible` and `opacity` are loaded but not applied at draw time.
+----diff --git a/examples/basic_map.rs b/examples/basic_map.rs
+----index db1feca..41a1859 100644
+------- a/examples/basic_map.rs
+----+++ b/examples/basic_map.rs
+----@@ -13,7 +13,7 @@ fn window_conf() -> Conf {
+---- 
+---- #[macroquad::main(window_conf)] // ❷ pass the window config function here
+---- async fn main() {
+-----    let map = Map::load("assets2/map.json")
+----+    let mut map = Map::load("assets2/map.json")
+----         .await
+----         .expect("Failed to load map");
+---- 
+----diff --git a/examples/objects.rs b/examples/objects.rs
+----index cd1ed75..9002986 100644
+------- a/examples/objects.rs
+----+++ b/examples/objects.rs
+----@@ -12,7 +12,7 @@ fn window_conf() -> Conf {
+---- 
+---- #[macroquad::main(window_conf)]
+---- async fn main() {
+-----    let map = Map::load("assets2/map.json")
+----+    let mut map = Map::load("assets2/map.json")
+----         .await
+----         .expect("Failed to load map");
+---- 
+----diff --git a/src.zip b/src.zip
+----index 60aeee9..c33c0f4 100644
+----Binary files a/src.zip and b/src.zip differ
+----diff --git a/src/map.rs b/src/map.rs
+----index f2209f0..1a59259 100644
+------- a/src/map.rs
+----+++ b/src/map.rs
+----@@ -2,7 +2,7 @@ use crate::ir_map::*;
+---- use crate::loader::json_loader::*;
+---- use crate::render::*;
+---- use crate::{
+-----    spatial::{rel, world_to_chunk, ChunkCoord, CHUNK_SIZE},
+----+    spatial::{rel, world_to_chunk, CHUNK_SIZE},
+----     GlobalIndex, LayerIdx, TileId,
+---- };
+---- use anyhow::Context;
+----@@ -10,6 +10,8 @@ use macroquad::prelude::*;
+---- use std::collections::HashMap;
+---- use std::path::Path;
+---- 
+----+pub type LayerId = u32;
+----+
+---- pub struct TilesetInfo {
+----     pub first_gid: u32,
+----     pub tilecount: u32,
+----@@ -22,18 +24,16 @@ pub struct TilesetInfo {
+---- }
+---- 
+---- pub struct ObjectLayer {
+----+    pub id: LayerId,
+----     pub name: String,
+----     pub visible: bool,
+----     pub opacity: f32,
+----     pub offset: Vec2,
+----     pub properties: Properties,
+----     pub objects: Vec<IrObject>,
+-----}
+-----
+-----#[derive(Clone, Copy)]
+-----struct ObjectRec {
+-----    object_idx: usize,
+-----    rel_pos: Vec2,
+----+    bucket_layer: LayerIdx,
+----+    seen_stamp_tiles: Vec<u32>,
+----+    seen_stamp_debug: Vec<u32>,
+---- }
+---- 
+---- #[derive(Clone, Copy)]
+----@@ -44,20 +44,22 @@ struct TileLayerDrawInfo {
+---- }
+---- 
+---- #[derive(Clone, Copy)]
+-----enum DrawLayer {
+----+enum LayerKindInfo {
+----     Tiles(usize),
+----     Objects(usize),
+----+    Unsupported,
+---- }
+---- 
+---- pub struct Map {
+----     pub index: GlobalIndex,
+----     pub tilesets: Vec<TilesetInfo>,
+----     object_layers: Vec<ObjectLayer>,
+-----    object_buckets: HashMap<ChunkCoord, HashMap<usize, Vec<ObjectRec>>>,
+----     debug_draw: bool,
+----+    frame_stamp: u32,
+----     gid_lut: Vec<u16>, //lookup table for tile GIDs to tileset indices
+----     tile_layers: Vec<TileLayerDrawInfo>,
+-----    draw_order: Vec<DrawLayer>,
+----+    draw_order: Vec<LayerId>,
+----+    layer_kind_by_id: HashMap<LayerId, LayerKindInfo>,
+----     pub tile_w: u32,
+----     pub tile_h: u32,
+---- }
+----@@ -125,80 +127,85 @@ impl Map {
+---- 
+----         let mut index = GlobalIndex::new();
+----         let mut object_layers = Vec::new();
+-----        let mut object_buckets: HashMap<ChunkCoord, HashMap<usize, Vec<ObjectRec>>> =
+-----            HashMap::new();
+----         let mut tile_layers: Vec<TileLayerDrawInfo> = Vec::new();
+-----        let mut draw_order: Vec<DrawLayer> = Vec::new();
+----+        let mut draw_order: Vec<LayerId> = Vec::new();
+----+        let mut layer_kind_by_id: HashMap<LayerId, LayerKindInfo> = HashMap::new();
+---- 
+----         for (lz, layer) in ir.layers.iter().enumerate() {
+-----            if let IrLayerKind::Objects { objects } = &layer.kind {
+----+            let stable_id = lz as LayerId;
+----+            draw_order.push(stable_id);
+----+
+----+            match &layer.kind {
+----+                IrLayerKind::Objects { objects } => {
+----                 let layer_idx = object_layers.len();
+----+                let bucket_layer = lz as LayerIdx;
+----                 object_layers.push(ObjectLayer {
+----+                    id: stable_id,
+----                     name: layer.name.clone(),
+----                     visible: layer.visible,
+----                     opacity: layer.opacity,
+----                     offset: layer.offset,
+----                     properties: layer.properties.clone(),
+----                     objects: objects.clone(),
+----+                    bucket_layer,
+----+                    seen_stamp_tiles: vec![0; objects.len()],
+----+                    seen_stamp_debug: vec![0; objects.len()],
+----                 });
+---- 
+-----                for (object_idx, obj) in objects.iter().enumerate() {
+-----                    let world = vec2(obj.x, obj.y) + layer.offset;
+-----                    let (min, max) = Self::object_aabb_world(obj, layer.offset);
+-----                    let chunk_min = world_to_chunk(min);
+-----                    let chunk_max = world_to_chunk(max);
+-----
+-----                    for cy in chunk_min.y..=chunk_max.y {
+-----                        for cx in chunk_min.x..=chunk_max.x {
+-----                            let cc = ChunkCoord { x: cx, y: cy };
+-----                            let by_layer = object_buckets.entry(cc).or_default();
+-----                            by_layer.entry(layer_idx).or_default().push(ObjectRec {
+-----                                object_idx,
+-----                                rel_pos: rel(world),
+-----                            });
+----+                    for (object_idx, obj) in objects.iter().enumerate() {
+----+                        let world = vec2(obj.x, obj.y) + layer.offset;
+----+                        let (min, max) = Self::object_aabb_world(obj, layer.offset);
+----+                        let chunk_min = world_to_chunk(min);
+----+                        let chunk_max = world_to_chunk(max);
+----+
+----+                        for cy in chunk_min.y..=chunk_max.y {
+----+                            for cx in chunk_min.x..=chunk_max.x {
+----+                                let cc = crate::spatial::ChunkCoord { x: cx, y: cy };
+----+                                index.insert_object(
+----+                                    bucket_layer,
+----+                                    cc,
+----+                                    crate::spatial::ObjectRec {
+----+                                        id: object_idx as u32,
+----+                                        rel_pos: rel(world),
+----+                                    },
+----+                                );
+----+                            }
+----                         }
+----                     }
+-----                }
+-----                draw_order.push(DrawLayer::Objects(layer_idx));
+-----                continue;
+-----            }
+-----
+-----            let lid = lz as LayerIdx;
+-----            let mut inserted_any = false;
+---- 
+-----            let (width, data) = match &layer.kind {
+----+                    layer_kind_by_id.insert(stable_id, LayerKindInfo::Objects(layer_idx));
+----+                }
+----                 IrLayerKind::Tiles {
+----                     width,
+----                     height: _,
+----                     data,
+-----                } => (width, data),
+-----                _ => continue,
+-----            };
+----+                } => {
+----+                    let tile_layer_idx = tile_layers.len();
+----+                    let lid = lz as LayerIdx;
+---- 
+-----            let tw = ir.tile_w as f32;
+-----            let th = ir.tile_h as f32;
+----+                    let tw = ir.tile_w as f32;
+----+                    let th = ir.tile_h as f32;
+----+                    for (idx, gid) in data.iter().enumerate() {
+----+                        if *gid == 0 {
+----+                            continue;
+----+                        }
+----+                        let col = idx % *width;
+----+                        let row = idx / *width;
+----+                        let mut world = vec2(col as f32 * tw, row as f32 * th);
+----+                        world += layer.offset;
+----+                        index.add_tile(TileId(*gid), lid, world);
+----+                    }
+---- 
+-----            for (idx, gid) in data.iter().enumerate() {
+-----                if *gid == 0 {
+-----                    continue;
+----+                    tile_layers.push(TileLayerDrawInfo {
+----+                        layer_id: lid,
+----+                        visible: layer.visible,
+----+                        opacity: layer.opacity.clamp(0.0, 1.0),
+----+                    });
+----+                    layer_kind_by_id.insert(stable_id, LayerKindInfo::Tiles(tile_layer_idx));
+----+                }
+----+                IrLayerKind::Unsupported => {
+----+                    layer_kind_by_id.insert(stable_id, LayerKindInfo::Unsupported);
+----                 }
+-----
+-----                let col = idx % *width;
+-----                let row = idx / *width;
+-----                let mut world = vec2(col as f32 * tw, row as f32 * th);
+-----                world += layer.offset;
+-----
+-----                index.add_tile(TileId(*gid), lid, world);
+-----                inserted_any = true;
+-----            }
+-----
+-----            if inserted_any {
+-----                tile_layers.push(TileLayerDrawInfo {
+-----                    layer_id: lid,
+-----                    visible: layer.visible,
+-----                    opacity: layer.opacity.clamp(0.0, 1.0),
+-----                });
+-----                draw_order.push(DrawLayer::Tiles(tile_layers.len() - 1));
+----             }
+----         }
+---- 
+----@@ -206,11 +213,12 @@ impl Map {
+----             index,
+----             tilesets,
+----             object_layers,
+-----            object_buckets,
+----             debug_draw: false,
+----+            frame_stamp: 0,
+----             gid_lut,
+----             tile_layers,
+----             draw_order,
+----+            layer_kind_by_id,
+----             tile_w: ir.tile_w,
+----             tile_h: ir.tile_h,
+----         })
+----@@ -258,6 +266,19 @@ impl Map {
+----         }
+----     }
+---- 
+----+    fn next_stamp(frame_stamp: &mut u32, object_layers: &mut [ObjectLayer]) -> u32 {
+----+        if *frame_stamp == u32::MAX {
+----+            for layer in object_layers {
+----+                layer.seen_stamp_tiles.fill(0);
+----+                layer.seen_stamp_debug.fill(0);
+----+            }
+----+            *frame_stamp = 1;
+----+            return 1;
+----+        }
+----+        *frame_stamp += 1;
+----+        *frame_stamp
+----+    }
+----+
+----     pub fn object_layers(&self) -> &[ObjectLayer] {
+----         &self.object_layers
+----     }
+----@@ -269,8 +290,7 @@ impl Map {
+----     }
+---- 
+----     #[inline]
+-----    fn params_for_flips(
+-----        &self,
+----+    fn params_for_flips_gid(
+----         gid: TileId,
+----         tile_w: f32,
+----         tile_h: f32,
+----@@ -295,39 +315,66 @@ impl Map {
+----     }
+---- 
+----     #[inline]
+-----    fn ts_for_gid(&self, gid: TileId) -> Option<(&TilesetInfo, u32)> {
+----+    fn params_for_flips(
+----+        &self,
+----+        gid: TileId,
+----+        tile_w: f32,
+----+        tile_h: f32,
+----+    ) -> (f32, bool, bool, Option<Vec2>) {
+----+        Self::params_for_flips_gid(gid, tile_w, tile_h)
+----+    }
+----+
+----+    #[inline]
+----+    fn ts_for_gid_from<'a>(
+----+        gid: TileId,
+----+        gid_lut: &'a [u16],
+----+        tilesets: &'a [TilesetInfo],
+----+    ) -> Option<(&'a TilesetInfo, u32)> {
+----         let clean = gid.clean() as usize;
+-----        if clean >= self.gid_lut.len() {
+----+        if clean >= gid_lut.len() {
+----             return None;
+----         }
+---- 
+-----        let idx = self.gid_lut[clean];
+----+        let idx = gid_lut[clean];
+----         if idx == u16::MAX {
+----             return None;
+----         }
+---- 
+-----        let ts = &self.tilesets[idx as usize];
+----+        let ts = &tilesets[idx as usize];
+----         Some((ts, gid.clean() - ts.first_gid))
+----     }
+---- 
+----+    #[inline]
+----+    fn ts_for_gid(&self, gid: TileId) -> Option<(&TilesetInfo, u32)> {
+----+        Self::ts_for_gid_from(gid, &self.gid_lut, &self.tilesets)
+----+    }
+----+
+----     pub fn draw_visible_rect(&self, view_min: Vec2, view_max: Vec2) {
+----         let view = query_visible_rect(&self.index, view_min, view_max);
+----         self.draw_chunks(view);
+----     }
+---- 
+-----    pub fn draw(&self, view_min: Vec2, view_max: Vec2) {
+-----        let view = query_visible_rect(&self.index, view_min, view_max);
+-----        for entry in &self.draw_order {
+-----            match entry {
+-----                DrawLayer::Tiles(tile_layer_idx) => {
+-----                    self.draw_tile_layer_from_view(&view, *tile_layer_idx);
+----+    pub fn draw(&mut self, view_min: Vec2, view_max: Vec2) {
+----+        let coords = Self::visible_coords_for_draw(view_min, view_max);
+----+        let draw_order = self.draw_order.clone();
+----+        for layer_id in &draw_order {
+----+            let Some(kind) = self.layer_kind_by_id.get(layer_id).copied() else {
+----+                continue;
+----+            };
+----+            match kind {
+----+                LayerKindInfo::Tiles(tile_layer_idx) => {
+----+                    self.draw_tile_layer_from_coords(&coords, tile_layer_idx);
+----                 }
+-----                DrawLayer::Objects(layer_idx) => {
+-----                    self.draw_object_tiles_layer_from_view(&view, *layer_idx);
+----+                LayerKindInfo::Objects(object_layer_idx) => {
+----+                    let stamp = Self::next_stamp(&mut self.frame_stamp, &mut self.object_layers);
+----+                    self.draw_object_tiles_layer_from_coords(&coords, object_layer_idx, stamp);
+----                     if self.debug_draw {
+-----                        self.draw_object_debug_layer_from_view(&view, *layer_idx);
+----+                        let stamp =
+----+                            Self::next_stamp(&mut self.frame_stamp, &mut self.object_layers);
+----+                        self.draw_object_debug_layer_from_coords(&coords, object_layer_idx, stamp);
+----                     }
+----                 }
+----+                LayerKindInfo::Unsupported => {}
+----             }
+----         }
+----     }
+----@@ -336,14 +383,14 @@ impl Map {
+----         self.debug_draw = enabled;
+----     }
+---- 
+-----    pub fn draw_objects_debug(&self, view_min: Vec2, view_max: Vec2) {
+-----        let view = query_visible_rect(&self.index, view_min, view_max);
+-----        self.draw_chunk_objects_debug(view);
+----+    pub fn draw_objects_debug(&mut self, view_min: Vec2, view_max: Vec2) {
+----+        let coords = Self::visible_coords_for_draw(view_min, view_max);
+----+        self.draw_chunk_objects_debug_coords(&coords);
+----     }
+---- 
+-----    pub fn draw_objects_tiles(&self, view_min: Vec2, view_max: Vec2) {
+-----        let view = query_visible_rect(&self.index, view_min, view_max);
+-----        self.draw_chunk_objects_tiles(view);
+----+    pub fn draw_objects_tiles(&mut self, view_min: Vec2, view_max: Vec2) {
+----+        let coords = Self::visible_coords_for_draw(view_min, view_max);
+----+        self.draw_chunk_objects_tiles_coords(&coords);
+----     }
+---- 
+----     fn draw_chunks(&self, view: LocalView) {
+----@@ -362,8 +409,8 @@ impl Map {
+----         let tint = Color::new(1.0, 1.0, 1.0, layer.opacity);
+---- 
+----         for LocalChunkView { coord: cc, layers } in &view.chunks {
+-----            if let Some(vec) = layers.get(&layer.layer_id) {
+-----                for rec in vec {
+----+            if let Some(bucket) = layers.get(&layer.layer_id) {
+----+                for rec in &bucket.tiles {
+----                     let (ts, local) = match self.ts_for_gid(rec.id) {
+----                         Some(x) => x,
+----                         None => continue,
+----@@ -404,20 +451,83 @@ impl Map {
+----         }
+----     }
+---- 
+-----    fn draw_chunk_objects_debug(&self, view: LocalView) {
+----+    fn draw_tile_layer_from_coords(&self, coords: &[crate::spatial::ChunkCoord], tile_layer_idx: usize) {
+----+        let Some(layer) = self.tile_layers.get(tile_layer_idx) else {
+----+            return;
+----+        };
+----+        if !layer.visible {
+----+            return;
+----+        }
+----+        let tint = Color::new(1.0, 1.0, 1.0, layer.opacity);
+----+
+----+        for cc in coords {
+----+            let Some(global_chunk) = self.index.buckets.get(cc) else {
+----+                continue;
+----+            };
+----+            let Some(bucket) = global_chunk.layers.get(&layer.layer_id) else {
+----+                continue;
+----+            };
+----+            for rec in &bucket.tiles {
+----+                let (ts, local) = match self.ts_for_gid(rec.id) {
+----+                    Some(x) => x,
+----+                    None => continue,
+----+                };
+----+
+----+                let col = local % ts.cols;
+----+                let row = local / ts.cols;
+----+                let sx = ts.margin + col * (ts.tile_w + ts.spacing);
+----+                let sy = ts.margin + row * (ts.tile_h + ts.spacing);
+----+
+----+                let x = ((cc.x * CHUNK_SIZE) as f32 + rec.rel_pos.x).round();
+----+                let y = ((cc.y * CHUNK_SIZE) as f32 + rec.rel_pos.y).round();
+----+
+----+                let (rotation, flip_x, flip_y, pivot) =
+----+                    self.params_for_flips(rec.id, ts.tile_w as f32, ts.tile_h as f32);
+----+
+----+                draw_texture_ex(
+----+                    &ts.tex,
+----+                    x,
+----+                    y,
+----+                    tint,
+----+                    DrawTextureParams {
+----+                        source: Some(Rect::new(
+----+                            sx as f32,
+----+                            sy as f32,
+----+                            ts.tile_w as f32,
+----+                            ts.tile_h as f32,
+----+                        )),
+----+                        rotation,
+----+                        flip_x,
+----+                        flip_y,
+----+                        pivot,
+----+                        ..Default::default()
+----+                    },
+----+                );
+----+            }
+----+        }
+----+    }
+----+
+----+    fn draw_chunk_objects_debug_coords(&mut self, coords: &[crate::spatial::ChunkCoord]) {
+----+        let stamp = Self::next_stamp(&mut self.frame_stamp, &mut self.object_layers);
+----         for layer_idx in 0..self.object_layers.len() {
+-----            self.draw_object_debug_layer_from_view(&view, layer_idx);
+----+            self.draw_object_debug_layer_from_coords(coords, layer_idx, stamp);
+----         }
+----     }
+---- 
+-----    fn draw_chunk_objects_tiles(&self, view: LocalView) {
+----+    fn draw_chunk_objects_tiles_coords(&mut self, coords: &[crate::spatial::ChunkCoord]) {
+----+        let stamp = Self::next_stamp(&mut self.frame_stamp, &mut self.object_layers);
+----         for layer_idx in 0..self.object_layers.len() {
+-----            self.draw_object_tiles_layer_from_view(&view, layer_idx);
+----+            self.draw_object_tiles_layer_from_coords(coords, layer_idx, stamp);
+----         }
+----     }
+---- 
+-----    fn draw_object_debug_layer_from_view(&self, view: &LocalView, layer_idx: usize) {
+-----        let Some(layer) = self.object_layers.get(layer_idx) else {
+----+    fn draw_object_debug_layer_from_coords(
+----+        &mut self,
+----+        coords: &[crate::spatial::ChunkCoord],
+----+        layer_idx: usize,
+----+        stamp: u32,
+----+    ) {
+----+        let Some(layer) = self.object_layers.get_mut(layer_idx) else {
+----             return;
+----         };
+----         if !layer.visible {
+----@@ -430,23 +540,25 @@ impl Map {
+----         let polyline_color = Color::new(PINK.r, PINK.g, PINK.b, alpha);
+----         let tile_color = Color::new(MAGENTA.r, MAGENTA.g, MAGENTA.b, alpha);
+---- 
+-----        let mut drawn = vec![false; layer.objects.len()];
+-----
+-----        for LocalChunkView { coord: cc, .. } in &view.chunks {
+-----            let Some(by_layer) = self.object_buckets.get(cc) else {
+----+        for cc in coords {
+----+            let Some(global_chunk) = self.index.buckets.get(cc) else {
+----                 continue;
+----             };
+-----            let Some(records) = by_layer.get(&layer_idx) else {
+----+            let Some(layer_bucket) = global_chunk.layers.get(&layer.bucket_layer) else {
+----                 continue;
+----             };
+----+            let records = &layer_bucket.objects;
+---- 
+----             for rec in records {
+-----                if drawn[rec.object_idx] {
+----+                let object_idx = rec.id as usize;
+----+                if object_idx >= layer.seen_stamp_debug.len()
+----+                    || layer.seen_stamp_debug[object_idx] == stamp
+----+                {
+----                     continue;
+----                 }
+-----                drawn[rec.object_idx] = true;
+----+                layer.seen_stamp_debug[object_idx] = stamp;
+---- 
+-----                let Some(obj) = layer.objects.get(rec.object_idx) else {
+----+                let Some(obj) = layer.objects.get(object_idx) else {
+----                     continue;
+----                 };
+----                 if !obj.visible {
+----@@ -504,8 +616,15 @@ impl Map {
+----         }
+----     }
+---- 
+-----    fn draw_object_tiles_layer_from_view(&self, view: &LocalView, layer_idx: usize) {
+-----        let Some(layer) = self.object_layers.get(layer_idx) else {
+----+    fn draw_object_tiles_layer_from_coords(
+----+        &mut self,
+----+        coords: &[crate::spatial::ChunkCoord],
+----+        layer_idx: usize,
+----+        stamp: u32,
+----+    ) {
+----+        let gid_lut = &self.gid_lut;
+----+        let tilesets = &self.tilesets;
+----+        let Some(layer) = self.object_layers.get_mut(layer_idx) else {
+----             return;
+----         };
+----         if !layer.visible {
+----@@ -513,23 +632,25 @@ impl Map {
+----         }
+----         let tint = Color::new(1.0, 1.0, 1.0, layer.opacity.clamp(0.0, 1.0));
+---- 
+-----        let mut drawn = vec![false; layer.objects.len()];
+-----
+-----        for LocalChunkView { coord: cc, .. } in &view.chunks {
+-----            let Some(by_layer) = self.object_buckets.get(cc) else {
+----+        for cc in coords {
+----+            let Some(global_chunk) = self.index.buckets.get(cc) else {
+----                 continue;
+----             };
+-----            let Some(records) = by_layer.get(&layer_idx) else {
+----+            let Some(layer_bucket) = global_chunk.layers.get(&layer.bucket_layer) else {
+----                 continue;
+----             };
+----+            let records = &layer_bucket.objects;
+---- 
+----             for rec in records {
+-----                if drawn[rec.object_idx] {
+----+                let object_idx = rec.id as usize;
+----+                if object_idx >= layer.seen_stamp_tiles.len()
+----+                    || layer.seen_stamp_tiles[object_idx] == stamp
+----+                {
+----                     continue;
+----                 }
+-----                drawn[rec.object_idx] = true;
+----+                layer.seen_stamp_tiles[object_idx] = stamp;
+---- 
+-----                let Some(obj) = layer.objects.get(rec.object_idx) else {
+----+                let Some(obj) = layer.objects.get(object_idx) else {
+----                     continue;
+----                 };
+----                 if !obj.visible {
+----@@ -546,7 +667,7 @@ impl Map {
+----                 );
+---- 
+----                 let gid = TileId(gid);
+-----                let Some((ts, local)) = self.ts_for_gid(gid) else {
+----+                let Some((ts, local)) = Self::ts_for_gid_from(gid, gid_lut, tilesets) else {
+----                     continue;
+----                 };
+---- 
+----@@ -566,7 +687,7 @@ impl Map {
+----                     ts.tile_h as f32
+----                 };
+---- 
+-----                let (flag_rotation, flip_x, flip_y, _) = self.params_for_flips(gid, w, h);
+----+                let (flag_rotation, flip_x, flip_y, _) = Self::params_for_flips_gid(gid, w, h);
+----                 let rotation = obj.rotation.to_radians() + flag_rotation;
+---- 
+----                 draw_texture_ex(
+----@@ -592,4 +713,15 @@ impl Map {
+----             }
+----         }
+----     }
+----+
+----+    fn visible_coords_for_draw(
+----+        view_min: Vec2,
+----+        view_max: Vec2,
+----+    ) -> Vec<crate::spatial::ChunkCoord> {
+----+        let pad = CHUNK_SIZE as f32;
+----+        visible_chunk_coords_rect(
+----+            vec2(view_min.x - pad, view_min.y - pad),
+----+            vec2(view_max.x + pad, view_max.y + pad),
+----+        )
+----+    }
+---- }
+----diff --git a/src/render/cull.rs b/src/render/cull.rs
+----index c8f0dca..1d4b87e 100644
+------- a/src/render/cull.rs
+----+++ b/src/render/cull.rs
+----@@ -1,5 +1,5 @@
+---- use crate::{
+-----    spatial::{ChunkCoord, TileRec, CHUNK_SIZE},
+----+    spatial::{ChunkCoord, LayerBucket, CHUNK_SIZE},
+----     GlobalIndex, LayerIdx,
+---- };
+---- use macroquad::prelude::*;
+----@@ -9,12 +9,34 @@ const CULL_MARGIN_CHUNKS: i32 = 1;
+---- 
+---- pub struct LocalChunkView<'g> {
+----     pub coord: ChunkCoord,
+-----    pub layers: &'g HashMap<LayerIdx, Vec<TileRec>>,
+----+    pub layers: &'g HashMap<LayerIdx, LayerBucket>,
+---- }
+---- pub struct LocalView<'g> {
+----     pub chunks: Vec<LocalChunkView<'g>>,
+---- }
+---- 
+----+pub fn visible_chunk_coords_rect(view_min: Vec2, view_max: Vec2) -> Vec<ChunkCoord> {
+----+    let mut cx_min = (view_min.x as i32).div_euclid(CHUNK_SIZE);
+----+    let mut cy_min = (view_min.y as i32).div_euclid(CHUNK_SIZE);
+----+    let mut cx_max = (view_max.x as i32).div_euclid(CHUNK_SIZE);
+----+    let mut cy_max = (view_max.y as i32).div_euclid(CHUNK_SIZE);
+----+
+----+    if cx_min > cx_max {
+----+        std::mem::swap(&mut cx_min, &mut cx_max);
+----+    }
+----+    if cy_min > cy_max {
+----+        std::mem::swap(&mut cy_min, &mut cy_max);
+----+    }
+----+
+----+    let mut coords = Vec::new();
+----+    for cy in cy_min..=cy_max {
+----+        for cx in cx_min..=cx_max {
+----+            coords.push(ChunkCoord { x: cx, y: cy });
+----+        }
+----+    }
+----+    coords
+----+}
+----+
+---- pub fn query_visible<'g>(g: &'g GlobalIndex, cam: &Camera2D) -> LocalView<'g> {
+----     let (viewport_width, viewport_height) = match cam.viewport {
+----         Some((_, _, w, h)) => (w as f32, h as f32),
+----@@ -45,6 +67,7 @@ pub fn query_visible<'g>(g: &'g GlobalIndex, cam: &Camera2D) -> LocalView<'g> {
+----             })
+----         }
+----     }
+----+    chunks.sort_by_key(|c| (c.coord.y, c.coord.x));
+---- 
+----     LocalView { chunks }
+---- }
+----@@ -77,8 +100,27 @@ pub fn query_visible_rect<'g>(g: &'g GlobalIndex, view_min: Vec2, view_max: Vec2
+----             })
+----         }
+----     }
+-----
+-----    //chunks.sort_by_key(|c| (c.coord.x, c.coord.y));
+----+    chunks.sort_by_key(|c| (c.coord.y, c.coord.x));
+---- 
+----     LocalView { chunks }
+---- }
+----+
+----+#[cfg(test)]
+----+mod tests {
+----+    use super::*;
+----+    use crate::spatial::TileId;
+----+
+----+    #[test]
+----+    fn query_visible_rect_returns_chunks_in_stable_order() {
+----+        let mut index = GlobalIndex::new();
+----+        index.add_tile(TileId(1), 0, vec2(520.0, 520.0)); // (2,2)
+----+        index.add_tile(TileId(1), 0, vec2(0.0, 0.0)); // (0,0)
+----+        index.add_tile(TileId(1), 0, vec2(260.0, 0.0)); // (1,0)
+----+        index.add_tile(TileId(1), 0, vec2(0.0, 260.0)); // (0,1)
+----+
+----+        let view = query_visible_rect(&index, vec2(0.0, 0.0), vec2(800.0, 800.0));
+----+        let coords: Vec<ChunkCoord> = view.chunks.iter().map(|c| c.coord).collect();
+----+
+----+        assert!(coords.windows(2).all(|w| (w[0].y, w[0].x) <= (w[1].y, w[1].x)));
+----+    }
+----+}
+----diff --git a/src/spatial/index.rs b/src/spatial/index.rs
+----index 102539c..94179b7 100644
+------- a/src/spatial/index.rs
+----+++ b/src/spatial/index.rs
+----@@ -68,8 +68,20 @@ pub struct TileRec {
+----     pub rel_pos: Vec2,
+---- }
+---- 
+----+#[derive(Debug, Clone)]
+----+pub struct ObjectRec {
+----+    pub id: u32,
+----+    pub rel_pos: Vec2,
+----+}
+----+
+----+#[derive(Debug, Clone, Default)]
+----+pub struct LayerBucket {
+----+    pub tiles: Vec<TileRec>,
+----+    pub objects: Vec<ObjectRec>,
+----+}
+----+
+---- pub struct GlobalChunk {
+-----    pub layers: HashMap<LayerIdx, Vec<TileRec>>,
+----+    pub layers: HashMap<LayerIdx, LayerBucket>,
+---- }
+---- 
+---- impl GlobalChunk {
+----@@ -114,7 +126,7 @@ impl GlobalIndex {
+----         let cc = world_to_chunk(world);
+----         let handle = self.alloc_handle();
+----         let bucket = self.buckets.entry(cc).or_insert_with(GlobalChunk::new);
+-----        let vec = bucket.layers.entry(layer).or_insert_with(Vec::new);
+----+        let vec = &mut bucket.layers.entry(layer).or_default().tiles;
+---- 
+----         let idx = vec.len();
+----         vec.push(TileRec {
+----@@ -129,4 +141,14 @@ impl GlobalIndex {
+----         });
+----         handle
+----     }
+----+
+----+    pub fn insert_object(&mut self, layer: LayerIdx, chunk: ChunkCoord, object_rec: ObjectRec) {
+----+        let bucket = self.buckets.entry(chunk).or_insert_with(GlobalChunk::new);
+----+        bucket
+----+            .layers
+----+            .entry(layer)
+----+            .or_default()
+----+            .objects
+----+            .push(object_rec);
+----+    }
+---- }
+----diff --git a/ticket_diff.txt b/ticket_diff.txt
+----index 6ab2401..12d162e 100644
+------- a/ticket_diff.txt
+----+++ b/ticket_diff.txt
+----@@ -1,1219 +0,0 @@
+-----diff --git a/Cargo.toml b/Cargo.toml
+-----index 67dcd35..51e6221 100644
+-------- a/Cargo.toml
+-----+++ b/Cargo.toml
+-----@@ -2,9 +2,13 @@
+----- name = "macroquad_tiled_clone"
+----- version = "0.1.0"
+----- edition = "2021"
+------authors = ["Your Name <you@example.com>"]
+-----+authors = ["B3Z0 <vlad.cotiga75@egmail.com>"]
+----- license = "MIT OR Apache-2.0"
+----- description = "Minimal Tiled JSON loader & renderer for Macroquad"
+-----+repository = "https://github.com/B3Z0/macroquad_tiled_clone.git"
+-----+readme = "README.md"
+-----+keywords = ["tiled", "macroquad", "tilemap", "gamedev"]
+-----+categories = ["game-development", "graphics"]
+----- 
+----- [dependencies]
+----- macroquad = "0.4"               # for rendering & textures
+-----diff --git a/README.md b/README.md
+-----index 217eb3b..bf04146 100644
+-------- a/README.md
+-----+++ b/README.md
+-----@@ -1,22 +1,58 @@
+----- # macroquad_tiled_clone
+----- 
+------Minimal Tiled JSON loader & renderer for Macroquad.
+-----+Minimal Tiled JSON loader and renderer for Macroquad.
+----- 
+------## Roadmap
+-----+## Supports
+----- 
+------- **Phase 1 (MVP):**  
+------  - Parse basic Tiled JSON (map metadata + single tile layer)  
+------  - Load one Texture2D, compute sprite rects  
+------  - Double‐loop draw with `draw_texture_ex`
+-----+- Tiled JSON maps (orthogonal) with external tilesets (`source` .json)
+-----+- Tile layers with `data` arrays
+-----+- Multiple tilesets (firstgid mapping)
+-----+- Per-layer offsets
+-----+- Tile flip/rotation flags from Tiled GIDs
+-----+- Rendering via `draw_texture_ex` with nearest filtering
+----- 
+------- **Phase 2:**  
+------  - Named layers, batching, image/object layers
+-----+## Not yet
+----- 
+------- **Phase 3+:**  
+------  - Animations, properties, infinite maps, isometric, extensions…
+-----+- Inline tilesets
+-----+- Image layers and object layers
+-----+- Infinite maps (chunked layers)
+-----+- Isometric or hex maps
+-----+- Tile properties and animations
+-----+- Layer visibility/opacity in rendering
+----- 
+------## Getting Started
+-----+## Quickstart
+----- 
+------1. Add to your project:  
+-----+1. Add to your project:
+-----    ```toml
+------   macroquad_tiled_clone = { git = "https://github.com/yourusername/macroquad_tiled_clone" }
+-----+   macroquad_tiled_clone = { git = "https://github.com/B3Z0/macroquad_tiled_clone.git" }
+-----+   ```
+-----+2. Run the example:
+-----+   ```bash
+-----+   cargo run --example basic_map
+-----+   ```
+-----+3. Load and draw a map:
+-----+   ```rust
+-----+   use macroquad::prelude::*;
+-----+   use macroquad_tiled_clone::map::Map;
+-----+
+-----+   #[macroquad::main("My Game")]
+-----+   async fn main() {
+-----+       let map = Map::load("assets2/map.json")
+-----+           .await
+-----+           .expect("Failed to load map");
+-----+
+-----+       loop {
+-----+           clear_background(BLACK);
+-----+           map.draw_visible_rect(Vec2::ZERO, vec2(screen_width(), screen_height()));
+-----+           next_frame().await;
+-----+       }
+-----+   }
+-----+   ```
+-----+
+-----+## Limitations
+-----+
+-----+- Map files must be `.json` exported from Tiled.
+-----+- Tilesets must be external JSON tilesets with a single atlas image.
+-----+- Non-tile layers are skipped.
+-----+- Infinite maps are not supported (no chunked `layers[].chunks`).
+-----+- Layer `visible` and `opacity` are loaded but not applied at draw time.
+-----diff --git a/assets2/map.json b/assets2/map.json
+-----index 0247cab..004956b 100644
+-------- a/assets2/map.json
+-----+++ b/assets2/map.json
+-----@@ -33,6 +33,82 @@
+-----          "x":0,
+-----          "y":0
+-----         }, 
+-----+        {
+-----+         "draworder":"topdown",
+-----+         "id":4,
+-----+         "name":"Object Layer 1",
+-----+         "objects":[
+-----+                {
+-----+                 "height":0,
+-----+                 "id":1,
+-----+                 "name":"Point 1",
+-----+                 "point":true,
+-----+                 "rotation":0,
+-----+                 "type":"",
+-----+                 "visible":true,
+-----+                 "width":0,
+-----+                 "x":286,
+-----+                 "y":271
+-----+                }, 
+-----+                {
+-----+                 "height":64,
+-----+                 "id":43,
+-----+                 "name":"SpawnArea",
+-----+                 "properties":[
+-----+                        {
+-----+                         "name":"spawn",
+-----+                         "type":"bool",
+-----+                         "value":true
+-----+                        }],
+-----+                 "rotation":0,
+-----+                 "type":"Trigger",
+-----+                 "visible":true,
+-----+                 "width":96,
+-----+                 "x":64,
+-----+                 "y":64
+-----+                }, 
+-----+                {
+-----+                 "gid":15,
+-----+                 "height":47,
+-----+                 "id":12,
+-----+                 "name":"",
+-----+                 "rotation":0,
+-----+                 "type":"",
+-----+                 "visible":true,
+-----+                 "width":59,
+-----+                 "x":471,
+-----+                 "y":190
+-----+                }, 
+-----+                {
+-----+                 "gid":15,
+-----+                 "height":89,
+-----+                 "id":13,
+-----+                 "name":"",
+-----+                 "rotation":0,
+-----+                 "type":"",
+-----+                 "visible":true,
+-----+                 "width":87,
+-----+                 "x":538,
+-----+                 "y":392
+-----+                }, 
+-----+                {
+-----+                 "gid":15,
+-----+                 "height":16,
+-----+                 "id":14,
+-----+                 "name":"",
+-----+                 "rotation":0,
+-----+                 "type":"",
+-----+                 "visible":true,
+-----+                 "width":20,
+-----+                 "x":447,
+-----+                 "y":420
+-----+                }],
+-----+         "opacity":1,
+-----+         "type":"objectgroup",
+-----+         "visible":true,
+-----+         "x":0,
+-----+         "y":0
+-----+        }, 
+-----         {
+-----          "data":[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+-----             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+-----@@ -95,11 +171,11 @@
+-----          "x":0,
+-----          "y":0
+-----         }],
+------ "nextlayerid":4,
+------ "nextobjectid":1,
+-----+ "nextlayerid":5,
+-----+ "nextobjectid":15,
+-----  "orientation":"orthogonal",
+-----  "renderorder":"right-down",
+------ "tiledversion":"1.10.2",
+-----+ "tiledversion":"1.11.2",
+-----  "tileheight":32,
+-----  "tilesets":[
+-----         {
+-----@@ -109,6 +185,10 @@
+-----         {
+-----          "firstgid":5,
+-----          "source":"tileset2.json"
+-----+        }, 
+-----+        {
+-----+         "firstgid":15,
+-----+         "source":"coin.json"
+-----         }],
+-----  "tilewidth":32,
+-----  "type":"map",
+-----diff --git a/examples/basic_map.rs b/examples/basic_map.rs
+-----index 54935dd..db1feca 100644
+-------- a/examples/basic_map.rs
+-----+++ b/examples/basic_map.rs
+-----@@ -22,7 +22,7 @@ async fn main() {
+-----     loop {
+-----         clear_background(BLACK);
+----- 
+------        map.draw_visible_rect(Vec2::ZERO, screen_size);
+-----+        map.draw(Vec2::ZERO, screen_size);
+----- 
+-----         // Draw the frame rate in the top-left corner
+-----         draw_text(
+-----diff --git a/src/ir_map.rs b/src/ir_map.rs
+-----index 45c3763..8abab3b 100644
+-------- a/src/ir_map.rs
+-----+++ b/src/ir_map.rs
+-----@@ -1,10 +1,98 @@
+----- // src/ir.rs
+----- use macroquad::prelude::*;
+-----+use std::collections::HashMap;
+-----+
+-----+#[derive(Clone, Debug, PartialEq)]
+-----+pub enum PropertyValue {
+-----+    Bool(bool),
+-----+    I32(i32),
+-----+    F32(f32),
+-----+    String(String),
+-----+}
+-----+
+-----+#[derive(Clone, Debug, Default, PartialEq)]
+-----+pub struct Properties(HashMap<String, PropertyValue>);
+-----+
+-----+impl Properties {
+-----+    pub fn new() -> Self {
+-----+        Self::default()
+-----+    }
+-----+
+-----+    pub fn insert(&mut self, key: String, value: PropertyValue) {
+-----+        self.0.insert(key, value);
+-----+    }
+-----+
+-----+    pub fn get(&self, key: &str) -> Option<&PropertyValue> {
+-----+        self.0.get(key)
+-----+    }
+-----+
+-----+    pub fn get_bool(&self, key: &str) -> Option<bool> {
+-----+        match self.0.get(key) {
+-----+            Some(PropertyValue::Bool(v)) => Some(*v),
+-----+            _ => None,
+-----+        }
+-----+    }
+-----+
+-----+    pub fn get_i32(&self, key: &str) -> Option<i32> {
+-----+        match self.0.get(key) {
+-----+            Some(PropertyValue::I32(v)) => Some(*v),
+-----+            _ => None,
+-----+        }
+-----+    }
+-----+
+-----+    pub fn get_f32(&self, key: &str) -> Option<f32> {
+-----+        match self.0.get(key) {
+-----+            Some(PropertyValue::F32(v)) => Some(*v),
+-----+            _ => None,
+-----+        }
+-----+    }
+-----+
+-----+    pub fn get_string(&self, key: &str) -> Option<&str> {
+-----+        match self.0.get(key) {
+-----+            Some(PropertyValue::String(v)) => Some(v.as_str()),
+-----+            _ => None,
+-----+        }
+-----+    }
+-----+}
+-----+
+-----+#[derive(Clone, Debug, PartialEq)]
+-----+pub enum IrObjectShape {
+-----+    Rectangle,
+-----+    Point,
+-----+    Polygon(Vec<Vec2>),
+-----+    Polyline(Vec<Vec2>),
+-----+    Tile {
+-----+        gid: u32,
+-----+    },
+-----+}
+-----+
+-----+#[derive(Clone, Debug, PartialEq)]
+-----+pub struct IrObject {
+-----+    pub id: u32,
+-----+    pub name: String,
+-----+    pub class_name: String,
+-----+    pub x: f32,
+-----+    pub y: f32,
+-----+    pub width: f32,
+-----+    pub height: f32,
+-----+    pub rotation: f32,
+-----+    pub visible: bool,
+-----+    pub shape: IrObjectShape,
+-----+    pub properties: Properties,
+-----+}
+-----+
+-----+#[derive(Clone, Debug, PartialEq)]
+-----+pub struct IrTileMetadata {
+-----+    pub id: u32,
+-----+    pub properties: Properties,
+-----+    pub objects: Vec<IrObject>,
+-----+}
+----- 
+----- /// Canonical, format-agnostic map.
+----- pub struct IrMap {
+-----     pub tile_w: u32,
+-----     pub tile_h: u32,
+-----+    pub properties: Properties,
+-----     pub tilesets: Vec<IrTileset>, // must be sorted by first_gid
+-----     pub layers: Vec<IrLayer>,     // draw order: array order
+----- }
+-----@@ -20,6 +108,8 @@ pub enum IrTileset {
+-----         columns: u32,
+-----         spacing: u32, // 0 if not used
+-----         margin: u32,  // 0 if not used
+-----+        properties: Properties,
+-----+        tiles: Vec<IrTileMetadata>,
+-----     },
+-----     // (later) ImagePerTile { first_gid, tiles: Vec<IrTileImage> },
+----- }
+-----@@ -30,6 +120,10 @@ pub enum IrLayerKind {
+-----         height: usize,
+-----         data: Vec<u32>, // raw GIDs (including flip flags ok)
+-----     },
+-----+    Objects {
+-----+        objects: Vec<IrObject>,
+-----+    },
+-----+    Unsupported,
+-----     // (later) Objects { ... }, Image { ... }
+----- }
+----- 
+-----@@ -38,5 +132,6 @@ pub struct IrLayer {
+-----     pub visible: bool,
+-----     pub opacity: f32,
+-----     pub offset: Vec2, // world offset for this layer
+-----+    pub properties: Properties,
+-----     pub kind: IrLayerKind,
+----- }
+-----diff --git a/src/loader/json_loader.rs b/src/loader/json_loader.rs
+-----index c2cff0c..9b5c064 100644
+-------- a/src/loader/json_loader.rs
+-----+++ b/src/loader/json_loader.rs
+-----@@ -3,12 +3,16 @@ use crate::ir_map::*;
+----- use anyhow::Context;
+----- use macroquad::prelude::*;
+----- use serde::Deserialize;
+-----+use serde_json::Value as JsonValue;
+----- use std::path::{Path, PathBuf};
+----- 
+----- #[derive(Deserialize)]
+----- struct JsonLayer {
+-----+    #[serde(default)]
+-----     data: Vec<u32>,
+-----+    #[serde(default)]
+-----     width: usize,
+-----+    #[serde(default)]
+-----     height: usize,
+-----     #[serde(default = "default_true")]
+-----     visible: bool,
+-----@@ -22,6 +26,10 @@ struct JsonLayer {
+-----     name: String,
+-----     #[serde(rename = "type")]
+-----     kind: Option<String>, // "tilelayer" expected here
+-----+    #[serde(default)]
+-----+    properties: Vec<JsonProperty>,
+-----+    #[serde(default)]
+-----+    objects: Vec<JsonObject>,
+----- }
+----- 
+----- fn default_true() -> bool {
+-----@@ -43,6 +51,8 @@ struct JsonMap {
+-----     tileheight: u32,
+-----     layers: Vec<JsonLayer>,
+-----     tilesets: Vec<JsonTilesetRef>,
+-----+    #[serde(default)]
+-----+    properties: Vec<JsonProperty>,
+----- }
+----- 
+----- #[derive(Deserialize)]
+-----@@ -56,6 +66,147 @@ struct ExternalTileset {
+-----     spacing: u32,
+-----     #[serde(default)]
+-----     margin: u32,
+-----+    #[serde(default)]
+-----+    properties: Vec<JsonProperty>,
+-----+    #[serde(default)]
+-----+    tiles: Vec<JsonTile>,
+-----+}
+-----+
+-----+#[derive(Deserialize)]
+-----+struct JsonProperty {
+-----+    name: String,
+-----+    #[serde(default, rename = "type")]
+-----+    kind: Option<String>,
+-----+    value: JsonValue,
+-----+}
+-----+
+-----+#[derive(Deserialize)]
+-----+struct JsonObject {
+-----+    #[serde(default)]
+-----+    id: u32,
+-----+    #[serde(default)]
+-----+    name: String,
+-----+    #[serde(default, rename = "type")]
+-----+    kind: String,
+-----+    #[serde(default)]
+-----+    class: String,
+-----+    #[serde(default)]
+-----+    x: f32,
+-----+    #[serde(default)]
+-----+    y: f32,
+-----+    #[serde(default)]
+-----+    width: f32,
+-----+    #[serde(default)]
+-----+    height: f32,
+-----+    #[serde(default)]
+-----+    rotation: f32,
+-----+    #[serde(default = "default_true")]
+-----+    visible: bool,
+-----+    #[serde(default)]
+-----+    point: bool,
+-----+    #[serde(default)]
+-----+    polygon: Vec<JsonObjectPoint>,
+-----+    #[serde(default)]
+-----+    polyline: Vec<JsonObjectPoint>,
+-----+    #[serde(default)]
+-----+    gid: Option<u32>,
+-----+    #[serde(default)]
+-----+    properties: Vec<JsonProperty>,
+-----+}
+-----+
+-----+#[derive(Deserialize)]
+-----+struct JsonObjectPoint {
+-----+    x: f32,
+-----+    y: f32,
+-----+}
+-----+
+-----+#[derive(Deserialize, Default)]
+-----+struct JsonObjectGroup {
+-----+    #[serde(default)]
+-----+    objects: Vec<JsonObject>,
+-----+}
+-----+
+-----+#[derive(Deserialize)]
+-----+struct JsonTile {
+-----+    id: u32,
+-----+    #[serde(default)]
+-----+    properties: Vec<JsonProperty>,
+-----+    #[serde(default)]
+-----+    objectgroup: JsonObjectGroup,
+-----+}
+-----+
+-----+fn json_property_to_ir(prop: JsonProperty) -> Option<(String, PropertyValue)> {
+-----+    let value = match prop.kind.as_deref() {
+-----+        Some("bool") => prop.value.as_bool().map(PropertyValue::Bool),
+-----+        Some("int") | Some("object") => prop
+-----+            .value
+-----+            .as_i64()
+-----+            .and_then(|n| i32::try_from(n).ok())
+-----+            .map(PropertyValue::I32),
+-----+        Some("float") => prop.value.as_f64().map(|n| PropertyValue::F32(n as f32)),
+-----+        Some("string") | Some("file") | Some("color") | Some("class") => {
+-----+            prop.value.as_str().map(|s| PropertyValue::String(s.to_owned()))
+-----+        }
+-----+        _ => {
+-----+            if let Some(v) = prop.value.as_bool() {
+-----+                Some(PropertyValue::Bool(v))
+-----+            } else if let Some(v) = prop.value.as_i64().and_then(|n| i32::try_from(n).ok()) {
+-----+                Some(PropertyValue::I32(v))
+-----+            } else if let Some(v) = prop.value.as_f64() {
+-----+                Some(PropertyValue::F32(v as f32))
+-----+            } else {
+-----+                prop.value
+-----+                    .as_str()
+-----+                    .map(|s| PropertyValue::String(s.to_owned()))
+-----+            }
+-----+        }
+-----+    }?;
+-----+
+-----+    Some((prop.name, value))
+-----+}
+-----+
+-----+fn properties_from_json(props: Vec<JsonProperty>) -> Properties {
+-----+    let mut out = Properties::new();
+-----+    for p in props {
+-----+        if let Some((name, value)) = json_property_to_ir(p) {
+-----+            out.insert(name, value);
+-----+        }
+-----+    }
+-----+    out
+-----+}
+-----+
+-----+fn object_to_ir(obj: JsonObject) -> IrObject {
+-----+    let shape = if let Some(gid) = obj.gid {
+-----+        IrObjectShape::Tile { gid }
+-----+    } else if obj.point {
+-----+        IrObjectShape::Point
+-----+    } else if !obj.polygon.is_empty() {
+-----+        IrObjectShape::Polygon(obj.polygon.into_iter().map(|p| vec2(p.x, p.y)).collect())
+-----+    } else if !obj.polyline.is_empty() {
+-----+        IrObjectShape::Polyline(obj.polyline.into_iter().map(|p| vec2(p.x, p.y)).collect())
+-----+    } else {
+-----+        IrObjectShape::Rectangle
+-----+    };
+-----+
+-----+    let class_name = if !obj.class.is_empty() {
+-----+        obj.class
+-----+    } else {
+-----+        obj.kind
+-----+    };
+-----+
+-----+    IrObject {
+-----+        id: obj.id,
+-----+        name: obj.name,
+-----+        class_name,
+-----+        x: obj.x,
+-----+        y: obj.y,
+-----+        width: obj.width,
+-----+        height: obj.height,
+-----+        rotation: obj.rotation,
+-----+        visible: obj.visible,
+-----+        shape,
+-----+        properties: properties_from_json(obj.properties),
+-----+    }
+----- }
+----- 
+----- pub fn decode_map_file_to_ir(path: &str) -> anyhow::Result<(IrMap, PathBuf)> {
+-----@@ -95,6 +246,16 @@ pub fn decode_map_file_to_ir(path: &str) -> anyhow::Result<(IrMap, PathBuf)> {
+-----             columns: ext.columns,
+-----             spacing: ext.spacing,
+-----             margin: ext.margin,
+-----+            properties: properties_from_json(ext.properties),
+-----+            tiles: ext
+-----+                .tiles
+-----+                .into_iter()
+-----+                .map(|tile| IrTileMetadata {
+-----+                    id: tile.id,
+-----+                    properties: properties_from_json(tile.properties),
+-----+                    objects: tile.objectgroup.objects.into_iter().map(object_to_ir).collect(),
+-----+                })
+-----+                .collect(),
+-----         });
+-----     }
+----- 
+-----@@ -103,23 +264,28 @@ pub fn decode_map_file_to_ir(path: &str) -> anyhow::Result<(IrMap, PathBuf)> {
+-----         IrTileset::Atlas { first_gid, .. } => *first_gid,
+-----     });
+----- 
+------    // Build IR layers (only tile layers for now)
+-----+    // Build IR layers
+-----     let mut ir_layers = Vec::with_capacity(j.layers.len());
+-----     for l in j.layers {
+------        if l.kind.as_deref().unwrap_or("tilelayer") != "tilelayer" {
+------            // skip non-tiles for now
+------            continue;
+------        }
+-----+        let properties = properties_from_json(l.properties);
+-----+        let layer_kind = match l.kind.as_deref().unwrap_or("tilelayer") {
+-----+            "tilelayer" => IrLayerKind::Tiles {
+-----+                width: l.width,
+-----+                height: l.height,
+-----+                data: l.data,
+-----+            },
+-----+            "objectgroup" => IrLayerKind::Objects {
+-----+                objects: l.objects.into_iter().map(object_to_ir).collect(),
+-----+            },
+-----+            _ => IrLayerKind::Unsupported,
+-----+        };
+-----         ir_layers.push(IrLayer {
+-----             name: l.name,
+-----             visible: l.visible,
+-----             opacity: l.opacity,
+-----             offset: vec2(l.offsetx, l.offsety),
+------            kind: IrLayerKind::Tiles {
+------                width: l.width,
+------                height: l.height,
+------                data: l.data,
+------            },
+-----+            properties,
+-----+            kind: layer_kind,
+-----         });
+-----     }
+----- 
+-----@@ -127,9 +293,123 @@ pub fn decode_map_file_to_ir(path: &str) -> anyhow::Result<(IrMap, PathBuf)> {
+-----         IrMap {
+-----             tile_w: j.tilewidth,
+-----             tile_h: j.tileheight,
+-----+            properties: properties_from_json(j.properties),
+-----             tilesets: ir_tilesets,
+-----             layers: ir_layers,
+-----         },
+-----         map_dir,
+-----     ))
+----- }
+-----+
+-----+#[cfg(test)]
+-----+mod tests {
+-----+    use super::*;
+-----+    use std::fs;
+-----+    use std::time::{SystemTime, UNIX_EPOCH};
+-----+
+-----+    fn temp_dir() -> PathBuf {
+-----+        let nanos = SystemTime::now()
+-----+            .duration_since(UNIX_EPOCH)
+-----+            .expect("clock went backwards")
+-----+            .as_nanos();
+-----+        let dir = std::env::temp_dir().join(format!("mq_tiled_props_{nanos}"));
+-----+        fs::create_dir_all(&dir).expect("failed to create temp dir");
+-----+        dir
+-----+    }
+-----+
+-----+    #[test]
+-----+    fn parses_properties_for_map_layer_object_tileset_and_tile() {
+-----+        let dir = temp_dir();
+-----+        let map_path = dir.join("map.json");
+-----+        let ts_path = dir.join("tileset.json");
+-----+
+-----+        let map_json = r#"{
+-----+          "tilewidth": 16,
+-----+          "tileheight": 16,
+-----+          "properties": [
+-----+            {"name":"is_night","type":"bool","value":true},
+-----+            {"name":"gravity","type":"float","value":9.8},
+-----+            {"name":"theme","type":"string","value":"forest"}
+-----+          ],
+-----+          "layers": [
+-----+            {
+-----+              "type":"tilelayer",
+-----+              "name":"ground",
+-----+              "width":2,
+-----+              "height":2,
+-----+              "data":[1,0,0,0],
+-----+              "properties":[
+-----+                {"name":"is_solid","type":"bool","value":true},
+-----+                {"name":"difficulty","type":"int","value":3}
+-----+              ]
+-----+            },
+-----+            {
+-----+              "type":"objectgroup",
+-----+              "name":"spawns",
+-----+              "objects":[
+-----+                {
+-----+                  "id": 7,
+-----+                  "name":"spawn_1",
+-----+                  "type":"spawn",
+-----+                  "properties":[{"name":"kind","type":"string","value":"player"}]
+-----+                }
+-----+              ],
+-----+              "properties":[{"name":"enabled","type":"bool","value":true}]
+-----+            }
+-----+          ],
+-----+          "tilesets":[{"firstgid":1,"source":"tileset.json"}]
+-----+        }"#;
+-----+
+-----+        let tileset_json = r#"{
+-----+          "tilewidth":16,
+-----+          "tileheight":16,
+-----+          "tilecount":4,
+-----+          "columns":2,
+-----+          "image":"tiles.png",
+-----+          "properties":[{"name":"biome","type":"string","value":"forest"}],
+-----+          "tiles":[
+-----+            {
+-----+              "id":0,
+-----+              "properties":[{"name":"damage","type":"int","value":10}],
+-----+              "objectgroup":{
+-----+                "objects":[
+-----+                  {"id":1,"name":"hitbox","type":"shape","properties":[{"name":"sensor","type":"bool","value":false}]}
+-----+                ]
+-----+              }
+-----+            }
+-----+          ]
+-----+        }"#;
+-----+
+-----+        fs::write(&map_path, map_json).expect("failed to write map");
+-----+        fs::write(&ts_path, tileset_json).expect("failed to write tileset");
+-----+
+-----+        let (ir, _) = decode_map_file_to_ir(map_path.to_str().expect("path utf8")).expect("decode");
+-----+
+-----+        assert_eq!(ir.properties.get_bool("is_night"), Some(true));
+-----+        assert_eq!(ir.properties.get_f32("gravity"), Some(9.8));
+-----+        assert_eq!(ir.properties.get_string("theme"), Some("forest"));
+-----+
+-----+        assert_eq!(ir.layers[0].properties.get_bool("is_solid"), Some(true));
+-----+        assert_eq!(ir.layers[0].properties.get_i32("difficulty"), Some(3));
+-----+
+-----+        match &ir.layers[1].kind {
+-----+            IrLayerKind::Objects { objects } => {
+-----+                assert_eq!(objects.len(), 1);
+-----+                assert_eq!(objects[0].properties.get_string("kind"), Some("player"));
+-----+            }
+-----+            _ => panic!("expected object layer"),
+-----+        }
+-----+
+-----+        match &ir.tilesets[0] {
+-----+            IrTileset::Atlas {
+-----+                properties, tiles, ..
+-----+            } => {
+-----+                assert_eq!(properties.get_string("biome"), Some("forest"));
+-----+                assert_eq!(tiles.len(), 1);
+-----+                assert_eq!(tiles[0].properties.get_i32("damage"), Some(10));
+-----+                assert_eq!(tiles[0].objects.len(), 1);
+-----+                assert_eq!(tiles[0].objects[0].properties.get_bool("sensor"), Some(false));
+-----+            }
+-----+        }
+-----+    }
+-----+}
+-----diff --git a/src/map.rs b/src/map.rs
+-----index a2826e7..76e1622 100644
+-------- a/src/map.rs
+-----+++ b/src/map.rs
+-----@@ -1,11 +1,14 @@
+----- use crate::ir_map::*;
+----- use crate::loader::json_loader::*;
+----- use crate::render::*;
+------use crate::{spatial::CHUNK_SIZE, GlobalIndex, LayerIdx, TileId};
+-----+use crate::{
+-----+    spatial::{rel, world_to_chunk, ChunkCoord, CHUNK_SIZE},
+-----+    GlobalIndex, LayerIdx, TileId,
+-----+};
+----- use anyhow::Context;
+----- use macroquad::prelude::*;
+-----+use std::collections::HashMap;
+----- use std::path::Path;
+------use std::thread::yield_now;
+----- 
+----- pub struct TilesetInfo {
+-----     pub first_gid: u32,
+-----@@ -18,9 +21,27 @@ pub struct TilesetInfo {
+-----     pub margin: u32,
+----- }
+----- 
+-----+pub struct ObjectLayer {
+-----+    pub name: String,
+-----+    pub visible: bool,
+-----+    pub opacity: f32,
+-----+    pub offset: Vec2,
+-----+    pub properties: Properties,
+-----+    pub objects: Vec<IrObject>,
+-----+}
+-----+
+-----+#[derive(Clone, Copy)]
+-----+struct ObjectRec {
+-----+    object_idx: usize,
+-----+    rel_pos: Vec2,
+-----+}
+-----+
+----- pub struct Map {
+-----     pub index: GlobalIndex,
+-----     pub tilesets: Vec<TilesetInfo>,
+-----+    object_layers: Vec<ObjectLayer>,
+-----+    object_buckets: HashMap<ChunkCoord, HashMap<usize, Vec<ObjectRec>>>,
+-----+    debug_draw: bool,
+-----     gid_lut: Vec<u16>, //lookup table for tile GIDs to tileset indices
+-----     layer_order: Vec<LayerIdx>,
+-----     pub tile_w: u32,
+-----@@ -41,13 +62,8 @@ impl Map {
+-----             match t {
+-----                 IrTileset::Atlas {
+-----                     first_gid,
+------                    image,
+------                    tile_w,
+------                    tile_h,
+-----                     tilecount,
+------                    columns,
+------                    spacing,
+------                    margin,
+-----+                    ..
+-----                 } => {
+-----                     max_gid = max_gid.max(*first_gid + tilecount - 1);
+-----                 }
+-----@@ -67,6 +83,7 @@ impl Map {
+-----                     columns,
+-----                     spacing,
+-----                     margin,
+-----+                    ..
+-----                 } => {
+-----                     let img_path = base_dir.join(image);
+-----                     let tex = load_texture(img_path.to_str().unwrap())
+-----@@ -93,36 +110,72 @@ impl Map {
+-----         }
+----- 
+-----         let mut index = GlobalIndex::new();
+-----+        let mut object_layers = Vec::new();
+-----+        let mut object_buckets: HashMap<ChunkCoord, HashMap<usize, Vec<ObjectRec>>> =
+-----+            HashMap::new();
+-----         let mut layer_order: Vec<LayerIdx> = Vec::new();
+----- 
+-----         for (lz, layer) in ir.layers.iter().enumerate() {
+-----+            if let IrLayerKind::Objects { objects } = &layer.kind {
+-----+                let layer_idx = object_layers.len();
+-----+                object_layers.push(ObjectLayer {
+-----+                    name: layer.name.clone(),
+-----+                    visible: layer.visible,
+-----+                    opacity: layer.opacity,
+-----+                    offset: layer.offset,
+-----+                    properties: layer.properties.clone(),
+-----+                    objects: objects.clone(),
+-----+                });
+-----+
+-----+                for (object_idx, obj) in objects.iter().enumerate() {
+-----+                    let world = vec2(obj.x, obj.y) + layer.offset;
+-----+                    let (min, max) = Self::object_aabb_world(obj, layer.offset);
+-----+                    let chunk_min = world_to_chunk(min);
+-----+                    let chunk_max = world_to_chunk(max);
+-----+
+-----+                    for cy in chunk_min.y..=chunk_max.y {
+-----+                        for cx in chunk_min.x..=chunk_max.x {
+-----+                            let cc = ChunkCoord { x: cx, y: cy };
+-----+                            let by_layer = object_buckets.entry(cc).or_default();
+-----+                            by_layer.entry(layer_idx).or_default().push(ObjectRec {
+-----+                                object_idx,
+-----+                                rel_pos: rel(world),
+-----+                            });
+-----+                        }
+-----+                    }
+-----+                }
+-----+                continue;
+-----+            }
+-----+
+-----             let lid = lz as LayerIdx;
+-----             let mut inserted_any = false;
+----- 
+------            let IrLayerKind::Tiles {
+------                width,
+------                height,
+------                data,
+------            } = &layer.kind;
+------
+------            {
+------                let tw = ir.tile_w as f32;
+------                let th = ir.tile_h as f32;
+------
+------                for (idx, gid) in data.iter().enumerate() {
+------                    if *gid == 0 {
+------                        continue;
+------                    }
+-----+            let (width, data) = match &layer.kind {
+-----+                IrLayerKind::Tiles {
+-----+                    width,
+-----+                    height: _,
+-----+                    data,
+-----+                } => (width, data),
+-----+                _ => continue,
+-----+            };
+-----+
+-----+            let tw = ir.tile_w as f32;
+-----+            let th = ir.tile_h as f32;
+-----+
+-----+            for (idx, gid) in data.iter().enumerate() {
+-----+                if *gid == 0 {
+-----+                    continue;
+-----+                }
+----- 
+------                    let col = idx % *width;
+------                    let row = idx / *width;
+------                    let mut world = vec2(col as f32 * tw, row as f32 * th);
+------                    world += layer.offset;
+-----+                let col = idx % *width;
+-----+                let row = idx / *width;
+-----+                let mut world = vec2(col as f32 * tw, row as f32 * th);
+-----+                world += layer.offset;
+----- 
+------                    index.add_tile(TileId(*gid), lz as LayerIdx, world);
+------                    inserted_any = true;
+------                }
+-----+                index.add_tile(TileId(*gid), lid, world);
+-----+                inserted_any = true;
+-----             }
+-----+
+-----             if inserted_any {
+-----                 layer_order.push(lid);
+-----             }
+-----@@ -131,6 +184,9 @@ impl Map {
+-----         Ok(Self {
+-----             index,
+-----             tilesets,
+-----+            object_layers,
+-----+            object_buckets,
+-----+            debug_draw: false,
+-----             gid_lut,
+-----             layer_order,
+-----             tile_w: ir.tile_w,
+-----@@ -138,6 +194,61 @@ impl Map {
+-----         })
+-----     }
+----- 
+-----+    fn object_aabb_world(obj: &IrObject, layer_offset: Vec2) -> (Vec2, Vec2) {
+-----+        let origin = vec2(obj.x, obj.y) + layer_offset;
+-----+
+-----+        match &obj.shape {
+-----+            IrObjectShape::Rectangle => {
+-----+                let x2 = origin.x + obj.width;
+-----+                let y2 = origin.y + obj.height;
+-----+                (
+-----+                    vec2(origin.x.min(x2), origin.y.min(y2)),
+-----+                    vec2(origin.x.max(x2), origin.y.max(y2)),
+-----+                )
+-----+            }
+-----+            IrObjectShape::Point => (
+-----+                origin - vec2(0.5, 0.5),
+-----+                origin + vec2(0.5, 0.5),
+-----+            ),
+-----+            IrObjectShape::Polygon(points) | IrObjectShape::Polyline(points) => {
+-----+                if points.is_empty() {
+-----+                    return (origin - vec2(0.5, 0.5), origin + vec2(0.5, 0.5));
+-----+                }
+-----+
+-----+                let mut min_x = origin.x;
+-----+                let mut min_y = origin.y;
+-----+                let mut max_x = origin.x;
+-----+                let mut max_y = origin.y;
+-----+
+-----+                for p in points {
+-----+                    let wp = origin + *p;
+-----+                    min_x = min_x.min(wp.x);
+-----+                    min_y = min_y.min(wp.y);
+-----+                    max_x = max_x.max(wp.x);
+-----+                    max_y = max_y.max(wp.y);
+-----+                }
+-----+
+-----+                (vec2(min_x, min_y), vec2(max_x, max_y))
+-----+            }
+-----+            IrObjectShape::Tile { .. } => {
+-----+                // Tile objects are drawn at (x, y - h), so AABB must match that.
+-----+                let w = if obj.width > 0.0 { obj.width } else { 1.0 };
+-----+                let h = if obj.height > 0.0 { obj.height } else { 1.0 };
+-----+                (vec2(origin.x, origin.y - h), vec2(origin.x + w, origin.y))
+-----+            }
+-----+        }
+-----+    }
+-----+
+-----+    pub fn object_layers(&self) -> &[ObjectLayer] {
+-----+        &self.object_layers
+-----+    }
+-----+
+-----+    pub fn objects(&self) -> impl Iterator<Item = &IrObject> {
+-----+        self.object_layers
+-----+            .iter()
+-----+            .flat_map(|layer| layer.objects.iter())
+-----+    }
+-----+
+-----     #[inline]
+-----     fn params_for_flips(
+-----         &self,
+-----@@ -145,21 +256,20 @@ impl Map {
+-----         tile_w: f32,
+-----         tile_h: f32,
+-----     ) -> (f32, bool, bool, Option<Vec2>) {
+------        let h = gid.flip_h(); // horizontal flip
+------        let v = gid.flip_v(); // vertical flip
+------        let d = gid.flip_d(); // diagonal flip
+-----+        let h = gid.flip_h();
+-----+        let v = gid.flip_v();
+-----+        let d = gid.flip_d();
+----- 
+------        let flip_x = h ^ d; // flip horizontally if not diagonal
+-----+        let flip_x = h ^ d;
+-----         let flip_y = v;
+-----         let pivot = Some(vec2(tile_w / 2.0, tile_h / 2.0));
+----- 
+-----         let rotation = match (h, v, d) {
+------            (false, _, _) => 0.0, // no flip
+------
+------            (true, false, false) => std::f32::consts::FRAC_PI_2, // + 90 degrees (with flip)
+------            (true, false, true) => std::f32::consts::FRAC_PI_2,  // - 90 defrees
+------            (true, true, false) => std::f32::consts::FRAC_PI_2,  // + 90 degrees
+------            (true, true, true) => std::f32::consts::PI,          // 180 degrees
+-----+            (false, _, _) => 0.0,
+-----+            (true, false, false) => std::f32::consts::FRAC_PI_2,
+-----+            (true, false, true) => std::f32::consts::FRAC_PI_2,
+-----+            (true, true, false) => std::f32::consts::FRAC_PI_2,
+-----+            (true, true, true) => std::f32::consts::PI,
+-----         };
+----- 
+-----         (rotation, flip_x, flip_y, pivot)
+-----@@ -167,27 +277,17 @@ impl Map {
+----- 
+-----     #[inline]
+-----     fn ts_for_gid(&self, gid: TileId) -> Option<(&TilesetInfo, u32)> {
+------        // Clean the tile ID by removing flip/rotation flags, keep only the actual ID number
+-----         let clean = gid.clean() as usize;
+------
+------        // Check if the cleaned ID is within the bounds of our lookup table
+-----         if clean >= self.gid_lut.len() {
+-----             return None;
+-----         }
+----- 
+------        // Get the tileset index from the lookup table
+-----         let idx = self.gid_lut[clean];
+------
+------        // If the index is u16::MAX, this means the tile ID doesn't map to any tileset
+-----         if idx == u16::MAX {
+-----             return None;
+-----         }
+----- 
+------        // Get the tileset info from the tilesets array
+-----         let ts = &self.tilesets[idx as usize];
+------
+------        // Return the tileset info and the local ID within that tileset
+------        // The local ID is calculated by subtracting the tileset's first GID from the cleaned tile ID
+-----         Some((ts, gid.clean() - ts.first_gid))
+-----     }
+----- 
+-----@@ -196,6 +296,28 @@ impl Map {
+-----         self.draw_chunks(view);
+-----     }
+----- 
+-----+    pub fn draw(&self, view_min: Vec2, view_max: Vec2) {
+-----+        self.draw_visible_rect(view_min, view_max);
+-----+        self.draw_objects_tiles(view_min, view_max);
+-----+        if self.debug_draw {
+-----+            self.draw_objects_debug(view_min, view_max);
+-----+        }
+-----+    }
+-----+
+-----+    pub fn set_debug_draw(&mut self, enabled: bool) {
+-----+        self.debug_draw = enabled;
+-----+    }
+-----+
+-----+    pub fn draw_objects_debug(&self, view_min: Vec2, view_max: Vec2) {
+-----+        let view = query_visible_rect(&self.index, view_min, view_max);
+-----+        self.draw_chunk_objects_debug(view);
+-----+    }
+-----+
+-----+    pub fn draw_objects_tiles(&self, view_min: Vec2, view_max: Vec2) {
+-----+        let view = query_visible_rect(&self.index, view_min, view_max);
+-----+        self.draw_chunk_objects_tiles(view);
+-----+    }
+-----+
+-----     fn draw_chunks(&self, view: LocalView) {
+-----         for &layer_id in &self.layer_order {
+-----             for LocalChunkView { coord: cc, layers } in &view.chunks {
+-----@@ -241,4 +363,172 @@ impl Map {
+-----             }
+-----         }
+-----     }
+-----+
+-----+    fn draw_chunk_objects_debug(&self, view: LocalView) {
+-----+        for (layer_idx, layer) in self.object_layers.iter().enumerate() {
+-----+            if !layer.visible {
+-----+                continue;
+-----+            }
+-----+
+-----+            let mut drawn = vec![false; layer.objects.len()];
+-----+
+-----+            for LocalChunkView { coord: cc, .. } in &view.chunks {
+-----+                let Some(by_layer) = self.object_buckets.get(cc) else {
+-----+                    continue;
+-----+                };
+-----+                let Some(records) = by_layer.get(&layer_idx) else {
+-----+                    continue;
+-----+                };
+-----+
+-----+                for rec in records {
+-----+                    if drawn[rec.object_idx] {
+-----+                        continue;
+-----+                    }
+-----+                    drawn[rec.object_idx] = true;
+-----+
+-----+                    let Some(obj) = layer.objects.get(rec.object_idx) else {
+-----+                        continue;
+-----+                    };
+-----+                    if !obj.visible {
+-----+                        continue;
+-----+                    }
+-----+
+-----+                    let origin = vec2(
+-----+                        (cc.x * CHUNK_SIZE) as f32 + rec.rel_pos.x,
+-----+                        (cc.y * CHUNK_SIZE) as f32 + rec.rel_pos.y,
+-----+                    );
+-----+
+-----+                    match &obj.shape {
+-----+                        IrObjectShape::Rectangle => {
+-----+                            draw_rectangle_lines(
+-----+                                origin.x,
+-----+                                origin.y,
+-----+                                obj.width.max(2.0),
+-----+                                obj.height.max(2.0),
+-----+                                2.0,
+-----+                                YELLOW,
+-----+                            );
+-----+                        }
+-----+                        IrObjectShape::Point => {
+-----+                            draw_circle(origin.x, origin.y, 5.0, GREEN);
+-----+                        }
+-----+                        IrObjectShape::Polygon(points) => {
+-----+                            if points.len() < 2 {
+-----+                                continue;
+-----+                            }
+-----+                            for i in 0..points.len() {
+-----+                                let a = origin + points[i];
+-----+                                let b = origin + points[(i + 1) % points.len()];
+-----+                                draw_line(a.x, a.y, b.x, b.y, 2.0, SKYBLUE);
+-----+                            }
+-----+                        }
+-----+                        IrObjectShape::Polyline(points) => {
+-----+                            for seg in points.windows(2) {
+-----+                                let a = origin + seg[0];
+-----+                                let b = origin + seg[1];
+-----+                                draw_line(a.x, a.y, b.x, b.y, 2.0, PINK);
+-----+                            }
+-----+                        }
+-----+                        IrObjectShape::Tile { .. } => {
+-----+                            draw_rectangle_lines(
+-----+                                origin.x,
+-----+                                origin.y - obj.height,
+-----+                                obj.width.max(16.0),
+-----+                                obj.height.max(16.0),
+-----+                                2.0,
+-----+                                MAGENTA,
+-----+                            );
+-----+                        }
+-----+                    }
+-----+                }
+-----+            }
+-----+        }
+-----+    }
+-----+
+-----+    fn draw_chunk_objects_tiles(&self, view: LocalView) {
+-----+        for (layer_idx, layer) in self.object_layers.iter().enumerate() {
+-----+            if !layer.visible {
+-----+                continue;
+-----+            }
+-----+
+-----+            let mut drawn = vec![false; layer.objects.len()];
+-----+
+-----+            for LocalChunkView { coord: cc, .. } in &view.chunks {
+-----+                let Some(by_layer) = self.object_buckets.get(cc) else {
+-----+                    continue;
+-----+                };
+-----+                let Some(records) = by_layer.get(&layer_idx) else {
+-----+                    continue;
+-----+                };
+-----+
+-----+                for rec in records {
+-----+                    if drawn[rec.object_idx] {
+-----+                        continue;
+-----+                    }
+-----+                    drawn[rec.object_idx] = true;
+-----+
+-----+                    let Some(obj) = layer.objects.get(rec.object_idx) else {
+-----+                        continue;
+-----+                    };
+-----+                    if !obj.visible {
+-----+                        continue;
+-----+                    }
+-----+
+-----+                    let IrObjectShape::Tile { gid } = obj.shape else {
+-----+                        continue;
+-----+                    };
+-----+
+-----+                    let origin = vec2(
+-----+                        (cc.x * CHUNK_SIZE) as f32 + rec.rel_pos.x,
+-----+                        (cc.y * CHUNK_SIZE) as f32 + rec.rel_pos.y,
+-----+                    );
+-----+
+-----+                    let gid = TileId(gid);
+-----+                    let Some((ts, local)) = self.ts_for_gid(gid) else {
+-----+                        continue;
+-----+                    };
+-----+
+-----+                    let col = local % ts.cols;
+-----+                    let row = local / ts.cols;
+-----+                    let sx = ts.margin + col * (ts.tile_w + ts.spacing);
+-----+                    let sy = ts.margin + row * (ts.tile_h + ts.spacing);
+-----+
+-----+                    let w = if obj.width > 0.0 {
+-----+                        obj.width
+-----+                    } else {
+-----+                        ts.tile_w as f32
+-----+                    };
+-----+                    let h = if obj.height > 0.0 {
+-----+                        obj.height
+-----+                    } else {
+-----+                        ts.tile_h as f32
+-----+                    };
+-----+
+-----+                    let (flag_rotation, flip_x, flip_y, _) = self.params_for_flips(gid, w, h);
+-----+                    let rotation = obj.rotation.to_radians() + flag_rotation;
+-----+
+-----+                    draw_texture_ex(
+-----+                        &ts.tex,
+-----+                        origin.x,
+-----+                        origin.y - h,
+-----+                        WHITE,
+-----+                        DrawTextureParams {
+-----+                            source: Some(Rect::new(
+-----+                                sx as f32,
+-----+                                sy as f32,
+-----+                                ts.tile_w as f32,
+-----+                                ts.tile_h as f32,
+-----+                            )),
+-----+                            dest_size: Some(vec2(w, h)),
+-----+                            rotation,
+-----+                            flip_x,
+-----+                            flip_y,
+-----+                            pivot: Some(vec2(0.0, h)),
+-----+                            ..Default::default()
+-----+                        },
+-----+                    );
+-----+                }
+-----+            }
+-----+        }
+-----+    }
+----- }
