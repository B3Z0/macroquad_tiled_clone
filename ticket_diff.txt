diff --git a/Cargo.toml b/Cargo.toml
index 67dcd35..51e6221 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -2,9 +2,13 @@
 name = "macroquad_tiled_clone"
 version = "0.1.0"
 edition = "2021"
-authors = ["Your Name <you@example.com>"]
+authors = ["B3Z0 <vlad.cotiga75@egmail.com>"]
 license = "MIT OR Apache-2.0"
 description = "Minimal Tiled JSON loader & renderer for Macroquad"
+repository = "https://github.com/B3Z0/macroquad_tiled_clone.git"
+readme = "README.md"
+keywords = ["tiled", "macroquad", "tilemap", "gamedev"]
+categories = ["game-development", "graphics"]
 
 [dependencies]
 macroquad = "0.4"               # for rendering & textures
diff --git a/README.md b/README.md
index 217eb3b..bf04146 100644
--- a/README.md
+++ b/README.md
@@ -1,22 +1,58 @@
 # macroquad_tiled_clone
 
-Minimal Tiled JSON loader & renderer for Macroquad.
+Minimal Tiled JSON loader and renderer for Macroquad.
 
-## Roadmap
+## Supports
 
-- **Phase 1 (MVP):**  
-  - Parse basic Tiled JSON (map metadata + single tile layer)  
-  - Load one Texture2D, compute sprite rects  
-  - Double‐loop draw with `draw_texture_ex`
+- Tiled JSON maps (orthogonal) with external tilesets (`source` .json)
+- Tile layers with `data` arrays
+- Multiple tilesets (firstgid mapping)
+- Per-layer offsets
+- Tile flip/rotation flags from Tiled GIDs
+- Rendering via `draw_texture_ex` with nearest filtering
 
-- **Phase 2:**  
-  - Named layers, batching, image/object layers
+## Not yet
 
-- **Phase 3+:**  
-  - Animations, properties, infinite maps, isometric, extensions…
+- Inline tilesets
+- Image layers and object layers
+- Infinite maps (chunked layers)
+- Isometric or hex maps
+- Tile properties and animations
+- Layer visibility/opacity in rendering
 
-## Getting Started
+## Quickstart
 
-1. Add to your project:  
+1. Add to your project:
    ```toml
-   macroquad_tiled_clone = { git = "https://github.com/yourusername/macroquad_tiled_clone" }
+   macroquad_tiled_clone = { git = "https://github.com/B3Z0/macroquad_tiled_clone.git" }
+   ```
+2. Run the example:
+   ```bash
+   cargo run --example basic_map
+   ```
+3. Load and draw a map:
+   ```rust
+   use macroquad::prelude::*;
+   use macroquad_tiled_clone::map::Map;
+
+   #[macroquad::main("My Game")]
+   async fn main() {
+       let map = Map::load("assets2/map.json")
+           .await
+           .expect("Failed to load map");
+
+       loop {
+           clear_background(BLACK);
+           map.draw_visible_rect(Vec2::ZERO, vec2(screen_width(), screen_height()));
+           next_frame().await;
+       }
+   }
+   ```
+
+## Limitations
+
+- Map files must be `.json` exported from Tiled.
+- Tilesets must be external JSON tilesets with a single atlas image.
+- Non-tile layers are skipped.
+- Infinite maps are not supported (no chunked `layers[].chunks`).
+- Layer `visible` and `opacity` are loaded but not applied at draw time.
diff --git a/assets2/map.json b/assets2/map.json
index 0247cab..004956b 100644
--- a/assets2/map.json
+++ b/assets2/map.json
@@ -33,6 +33,82 @@
          "x":0,
          "y":0
         }, 
+        {
+         "draworder":"topdown",
+         "id":4,
+         "name":"Object Layer 1",
+         "objects":[
+                {
+                 "height":0,
+                 "id":1,
+                 "name":"Point 1",
+                 "point":true,
+                 "rotation":0,
+                 "type":"",
+                 "visible":true,
+                 "width":0,
+                 "x":286,
+                 "y":271
+                }, 
+                {
+                 "height":64,
+                 "id":43,
+                 "name":"SpawnArea",
+                 "properties":[
+                        {
+                         "name":"spawn",
+                         "type":"bool",
+                         "value":true
+                        }],
+                 "rotation":0,
+                 "type":"Trigger",
+                 "visible":true,
+                 "width":96,
+                 "x":64,
+                 "y":64
+                }, 
+                {
+                 "gid":15,
+                 "height":47,
+                 "id":12,
+                 "name":"",
+                 "rotation":0,
+                 "type":"",
+                 "visible":true,
+                 "width":59,
+                 "x":471,
+                 "y":190
+                }, 
+                {
+                 "gid":15,
+                 "height":89,
+                 "id":13,
+                 "name":"",
+                 "rotation":0,
+                 "type":"",
+                 "visible":true,
+                 "width":87,
+                 "x":538,
+                 "y":392
+                }, 
+                {
+                 "gid":15,
+                 "height":16,
+                 "id":14,
+                 "name":"",
+                 "rotation":0,
+                 "type":"",
+                 "visible":true,
+                 "width":20,
+                 "x":447,
+                 "y":420
+                }],
+         "opacity":1,
+         "type":"objectgroup",
+         "visible":true,
+         "x":0,
+         "y":0
+        }, 
         {
          "data":[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@@ -95,11 +171,11 @@
          "x":0,
          "y":0
         }],
- "nextlayerid":4,
- "nextobjectid":1,
+ "nextlayerid":5,
+ "nextobjectid":15,
  "orientation":"orthogonal",
  "renderorder":"right-down",
- "tiledversion":"1.10.2",
+ "tiledversion":"1.11.2",
  "tileheight":32,
  "tilesets":[
         {
@@ -109,6 +185,10 @@
         {
          "firstgid":5,
          "source":"tileset2.json"
+        }, 
+        {
+         "firstgid":15,
+         "source":"coin.json"
         }],
  "tilewidth":32,
  "type":"map",
diff --git a/examples/basic_map.rs b/examples/basic_map.rs
index 54935dd..db1feca 100644
--- a/examples/basic_map.rs
+++ b/examples/basic_map.rs
@@ -22,7 +22,7 @@ async fn main() {
     loop {
         clear_background(BLACK);
 
-        map.draw_visible_rect(Vec2::ZERO, screen_size);
+        map.draw(Vec2::ZERO, screen_size);
 
         // Draw the frame rate in the top-left corner
         draw_text(
diff --git a/src/ir_map.rs b/src/ir_map.rs
index 45c3763..8abab3b 100644
--- a/src/ir_map.rs
+++ b/src/ir_map.rs
@@ -1,10 +1,98 @@
 // src/ir.rs
 use macroquad::prelude::*;
+use std::collections::HashMap;
+
+#[derive(Clone, Debug, PartialEq)]
+pub enum PropertyValue {
+    Bool(bool),
+    I32(i32),
+    F32(f32),
+    String(String),
+}
+
+#[derive(Clone, Debug, Default, PartialEq)]
+pub struct Properties(HashMap<String, PropertyValue>);
+
+impl Properties {
+    pub fn new() -> Self {
+        Self::default()
+    }
+
+    pub fn insert(&mut self, key: String, value: PropertyValue) {
+        self.0.insert(key, value);
+    }
+
+    pub fn get(&self, key: &str) -> Option<&PropertyValue> {
+        self.0.get(key)
+    }
+
+    pub fn get_bool(&self, key: &str) -> Option<bool> {
+        match self.0.get(key) {
+            Some(PropertyValue::Bool(v)) => Some(*v),
+            _ => None,
+        }
+    }
+
+    pub fn get_i32(&self, key: &str) -> Option<i32> {
+        match self.0.get(key) {
+            Some(PropertyValue::I32(v)) => Some(*v),
+            _ => None,
+        }
+    }
+
+    pub fn get_f32(&self, key: &str) -> Option<f32> {
+        match self.0.get(key) {
+            Some(PropertyValue::F32(v)) => Some(*v),
+            _ => None,
+        }
+    }
+
+    pub fn get_string(&self, key: &str) -> Option<&str> {
+        match self.0.get(key) {
+            Some(PropertyValue::String(v)) => Some(v.as_str()),
+            _ => None,
+        }
+    }
+}
+
+#[derive(Clone, Debug, PartialEq)]
+pub enum IrObjectShape {
+    Rectangle,
+    Point,
+    Polygon(Vec<Vec2>),
+    Polyline(Vec<Vec2>),
+    Tile {
+        gid: u32,
+    },
+}
+
+#[derive(Clone, Debug, PartialEq)]
+pub struct IrObject {
+    pub id: u32,
+    pub name: String,
+    pub class_name: String,
+    pub x: f32,
+    pub y: f32,
+    pub width: f32,
+    pub height: f32,
+    pub rotation: f32,
+    pub visible: bool,
+    pub shape: IrObjectShape,
+    pub properties: Properties,
+}
+
+#[derive(Clone, Debug, PartialEq)]
+pub struct IrTileMetadata {
+    pub id: u32,
+    pub properties: Properties,
+    pub objects: Vec<IrObject>,
+}
 
 /// Canonical, format-agnostic map.
 pub struct IrMap {
     pub tile_w: u32,
     pub tile_h: u32,
+    pub properties: Properties,
     pub tilesets: Vec<IrTileset>, // must be sorted by first_gid
     pub layers: Vec<IrLayer>,     // draw order: array order
 }
@@ -20,6 +108,8 @@ pub enum IrTileset {
         columns: u32,
         spacing: u32, // 0 if not used
         margin: u32,  // 0 if not used
+        properties: Properties,
+        tiles: Vec<IrTileMetadata>,
     },
     // (later) ImagePerTile { first_gid, tiles: Vec<IrTileImage> },
 }
@@ -30,6 +120,10 @@ pub enum IrLayerKind {
         height: usize,
         data: Vec<u32>, // raw GIDs (including flip flags ok)
     },
+    Objects {
+        objects: Vec<IrObject>,
+    },
+    Unsupported,
     // (later) Objects { ... }, Image { ... }
 }
 
@@ -38,5 +132,6 @@ pub struct IrLayer {
     pub visible: bool,
     pub opacity: f32,
     pub offset: Vec2, // world offset for this layer
+    pub properties: Properties,
     pub kind: IrLayerKind,
 }
diff --git a/src/loader/json_loader.rs b/src/loader/json_loader.rs
index c2cff0c..9b5c064 100644
--- a/src/loader/json_loader.rs
+++ b/src/loader/json_loader.rs
@@ -3,12 +3,16 @@ use crate::ir_map::*;
 use anyhow::Context;
 use macroquad::prelude::*;
 use serde::Deserialize;
+use serde_json::Value as JsonValue;
 use std::path::{Path, PathBuf};
 
 #[derive(Deserialize)]
 struct JsonLayer {
+    #[serde(default)]
     data: Vec<u32>,
+    #[serde(default)]
     width: usize,
+    #[serde(default)]
     height: usize,
     #[serde(default = "default_true")]
     visible: bool,
@@ -22,6 +26,10 @@ struct JsonLayer {
     name: String,
     #[serde(rename = "type")]
     kind: Option<String>, // "tilelayer" expected here
+    #[serde(default)]
+    properties: Vec<JsonProperty>,
+    #[serde(default)]
+    objects: Vec<JsonObject>,
 }
 
 fn default_true() -> bool {
@@ -43,6 +51,8 @@ struct JsonMap {
     tileheight: u32,
     layers: Vec<JsonLayer>,
     tilesets: Vec<JsonTilesetRef>,
+    #[serde(default)]
+    properties: Vec<JsonProperty>,
 }
 
 #[derive(Deserialize)]
@@ -56,6 +66,147 @@ struct ExternalTileset {
     spacing: u32,
     #[serde(default)]
     margin: u32,
+    #[serde(default)]
+    properties: Vec<JsonProperty>,
+    #[serde(default)]
+    tiles: Vec<JsonTile>,
+}
+
+#[derive(Deserialize)]
+struct JsonProperty {
+    name: String,
+    #[serde(default, rename = "type")]
+    kind: Option<String>,
+    value: JsonValue,
+}
+
+#[derive(Deserialize)]
+struct JsonObject {
+    #[serde(default)]
+    id: u32,
+    #[serde(default)]
+    name: String,
+    #[serde(default, rename = "type")]
+    kind: String,
+    #[serde(default)]
+    class: String,
+    #[serde(default)]
+    x: f32,
+    #[serde(default)]
+    y: f32,
+    #[serde(default)]
+    width: f32,
+    #[serde(default)]
+    height: f32,
+    #[serde(default)]
+    rotation: f32,
+    #[serde(default = "default_true")]
+    visible: bool,
+    #[serde(default)]
+    point: bool,
+    #[serde(default)]
+    polygon: Vec<JsonObjectPoint>,
+    #[serde(default)]
+    polyline: Vec<JsonObjectPoint>,
+    #[serde(default)]
+    gid: Option<u32>,
+    #[serde(default)]
+    properties: Vec<JsonProperty>,
+}
+
+#[derive(Deserialize)]
+struct JsonObjectPoint {
+    x: f32,
+    y: f32,
+}
+
+#[derive(Deserialize, Default)]
+struct JsonObjectGroup {
+    #[serde(default)]
+    objects: Vec<JsonObject>,
+}
+
+#[derive(Deserialize)]
+struct JsonTile {
+    id: u32,
+    #[serde(default)]
+    properties: Vec<JsonProperty>,
+    #[serde(default)]
+    objectgroup: JsonObjectGroup,
+}
+
+fn json_property_to_ir(prop: JsonProperty) -> Option<(String, PropertyValue)> {
+    let value = match prop.kind.as_deref() {
+        Some("bool") => prop.value.as_bool().map(PropertyValue::Bool),
+        Some("int") | Some("object") => prop
+            .value
+            .as_i64()
+            .and_then(|n| i32::try_from(n).ok())
+            .map(PropertyValue::I32),
+        Some("float") => prop.value.as_f64().map(|n| PropertyValue::F32(n as f32)),
+        Some("string") | Some("file") | Some("color") | Some("class") => {
+            prop.value.as_str().map(|s| PropertyValue::String(s.to_owned()))
+        }
+        _ => {
+            if let Some(v) = prop.value.as_bool() {
+                Some(PropertyValue::Bool(v))
+            } else if let Some(v) = prop.value.as_i64().and_then(|n| i32::try_from(n).ok()) {
+                Some(PropertyValue::I32(v))
+            } else if let Some(v) = prop.value.as_f64() {
+                Some(PropertyValue::F32(v as f32))
+            } else {
+                prop.value
+                    .as_str()
+                    .map(|s| PropertyValue::String(s.to_owned()))
+            }
+        }
+    }?;
+
+    Some((prop.name, value))
+}
+
+fn properties_from_json(props: Vec<JsonProperty>) -> Properties {
+    let mut out = Properties::new();
+    for p in props {
+        if let Some((name, value)) = json_property_to_ir(p) {
+            out.insert(name, value);
+        }
+    }
+    out
+}
+
+fn object_to_ir(obj: JsonObject) -> IrObject {
+    let shape = if let Some(gid) = obj.gid {
+        IrObjectShape::Tile { gid }
+    } else if obj.point {
+        IrObjectShape::Point
+    } else if !obj.polygon.is_empty() {
+        IrObjectShape::Polygon(obj.polygon.into_iter().map(|p| vec2(p.x, p.y)).collect())
+    } else if !obj.polyline.is_empty() {
+        IrObjectShape::Polyline(obj.polyline.into_iter().map(|p| vec2(p.x, p.y)).collect())
+    } else {
+        IrObjectShape::Rectangle
+    };
+
+    let class_name = if !obj.class.is_empty() {
+        obj.class
+    } else {
+        obj.kind
+    };
+
+    IrObject {
+        id: obj.id,
+        name: obj.name,
+        class_name,
+        x: obj.x,
+        y: obj.y,
+        width: obj.width,
+        height: obj.height,
+        rotation: obj.rotation,
+        visible: obj.visible,
+        shape,
+        properties: properties_from_json(obj.properties),
+    }
 }
 
 pub fn decode_map_file_to_ir(path: &str) -> anyhow::Result<(IrMap, PathBuf)> {
@@ -95,6 +246,16 @@ pub fn decode_map_file_to_ir(path: &str) -> anyhow::Result<(IrMap, PathBuf)> {
             columns: ext.columns,
             spacing: ext.spacing,
             margin: ext.margin,
+            properties: properties_from_json(ext.properties),
+            tiles: ext
+                .tiles
+                .into_iter()
+                .map(|tile| IrTileMetadata {
+                    id: tile.id,
+                    properties: properties_from_json(tile.properties),
+                    objects: tile.objectgroup.objects.into_iter().map(object_to_ir).collect(),
+                })
+                .collect(),
         });
     }
 
@@ -103,23 +264,28 @@ pub fn decode_map_file_to_ir(path: &str) -> anyhow::Result<(IrMap, PathBuf)> {
         IrTileset::Atlas { first_gid, .. } => *first_gid,
     });
 
-    // Build IR layers (only tile layers for now)
+    // Build IR layers
     let mut ir_layers = Vec::with_capacity(j.layers.len());
     for l in j.layers {
-        if l.kind.as_deref().unwrap_or("tilelayer") != "tilelayer" {
-            // skip non-tiles for now
-            continue;
-        }
+        let properties = properties_from_json(l.properties);
+        let layer_kind = match l.kind.as_deref().unwrap_or("tilelayer") {
+            "tilelayer" => IrLayerKind::Tiles {
+                width: l.width,
+                height: l.height,
+                data: l.data,
+            },
+            "objectgroup" => IrLayerKind::Objects {
+                objects: l.objects.into_iter().map(object_to_ir).collect(),
+            },
+            _ => IrLayerKind::Unsupported,
+        };
         ir_layers.push(IrLayer {
             name: l.name,
             visible: l.visible,
             opacity: l.opacity,
             offset: vec2(l.offsetx, l.offsety),
-            kind: IrLayerKind::Tiles {
-                width: l.width,
-                height: l.height,
-                data: l.data,
-            },
+            properties,
+            kind: layer_kind,
         });
     }
 
@@ -127,9 +293,123 @@ pub fn decode_map_file_to_ir(path: &str) -> anyhow::Result<(IrMap, PathBuf)> {
         IrMap {
             tile_w: j.tilewidth,
             tile_h: j.tileheight,
+            properties: properties_from_json(j.properties),
             tilesets: ir_tilesets,
             layers: ir_layers,
         },
         map_dir,
     ))
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use std::fs;
+    use std::time::{SystemTime, UNIX_EPOCH};
+
+    fn temp_dir() -> PathBuf {
+        let nanos = SystemTime::now()
+            .duration_since(UNIX_EPOCH)
+            .expect("clock went backwards")
+            .as_nanos();
+        let dir = std::env::temp_dir().join(format!("mq_tiled_props_{nanos}"));
+        fs::create_dir_all(&dir).expect("failed to create temp dir");
+        dir
+    }
+
+    #[test]
+    fn parses_properties_for_map_layer_object_tileset_and_tile() {
+        let dir = temp_dir();
+        let map_path = dir.join("map.json");
+        let ts_path = dir.join("tileset.json");
+
+        let map_json = r#"{
+          "tilewidth": 16,
+          "tileheight": 16,
+          "properties": [
+            {"name":"is_night","type":"bool","value":true},
+            {"name":"gravity","type":"float","value":9.8},
+            {"name":"theme","type":"string","value":"forest"}
+          ],
+          "layers": [
+            {
+              "type":"tilelayer",
+              "name":"ground",
+              "width":2,
+              "height":2,
+              "data":[1,0,0,0],
+              "properties":[
+                {"name":"is_solid","type":"bool","value":true},
+                {"name":"difficulty","type":"int","value":3}
+              ]
+            },
+            {
+              "type":"objectgroup",
+              "name":"spawns",
+              "objects":[
+                {
+                  "id": 7,
+                  "name":"spawn_1",
+                  "type":"spawn",
+                  "properties":[{"name":"kind","type":"string","value":"player"}]
+                }
+              ],
+              "properties":[{"name":"enabled","type":"bool","value":true}]
+            }
+          ],
+          "tilesets":[{"firstgid":1,"source":"tileset.json"}]
+        }"#;
+
+        let tileset_json = r#"{
+          "tilewidth":16,
+          "tileheight":16,
+          "tilecount":4,
+          "columns":2,
+          "image":"tiles.png",
+          "properties":[{"name":"biome","type":"string","value":"forest"}],
+          "tiles":[
+            {
+              "id":0,
+              "properties":[{"name":"damage","type":"int","value":10}],
+              "objectgroup":{
+                "objects":[
+                  {"id":1,"name":"hitbox","type":"shape","properties":[{"name":"sensor","type":"bool","value":false}]}
+                ]
+              }
+            }
+          ]
+        }"#;
+
+        fs::write(&map_path, map_json).expect("failed to write map");
+        fs::write(&ts_path, tileset_json).expect("failed to write tileset");
+
+        let (ir, _) = decode_map_file_to_ir(map_path.to_str().expect("path utf8")).expect("decode");
+
+        assert_eq!(ir.properties.get_bool("is_night"), Some(true));
+        assert_eq!(ir.properties.get_f32("gravity"), Some(9.8));
+        assert_eq!(ir.properties.get_string("theme"), Some("forest"));
+
+        assert_eq!(ir.layers[0].properties.get_bool("is_solid"), Some(true));
+        assert_eq!(ir.layers[0].properties.get_i32("difficulty"), Some(3));
+
+        match &ir.layers[1].kind {
+            IrLayerKind::Objects { objects } => {
+                assert_eq!(objects.len(), 1);
+                assert_eq!(objects[0].properties.get_string("kind"), Some("player"));
+            }
+            _ => panic!("expected object layer"),
+        }
+
+        match &ir.tilesets[0] {
+            IrTileset::Atlas {
+                properties, tiles, ..
+            } => {
+                assert_eq!(properties.get_string("biome"), Some("forest"));
+                assert_eq!(tiles.len(), 1);
+                assert_eq!(tiles[0].properties.get_i32("damage"), Some(10));
+                assert_eq!(tiles[0].objects.len(), 1);
+                assert_eq!(tiles[0].objects[0].properties.get_bool("sensor"), Some(false));
+            }
+        }
+    }
+}
diff --git a/src/map.rs b/src/map.rs
index a2826e7..76e1622 100644
--- a/src/map.rs
+++ b/src/map.rs
@@ -1,11 +1,14 @@
 use crate::ir_map::*;
 use crate::loader::json_loader::*;
 use crate::render::*;
-use crate::{spatial::CHUNK_SIZE, GlobalIndex, LayerIdx, TileId};
+use crate::{
+    spatial::{rel, world_to_chunk, ChunkCoord, CHUNK_SIZE},
+    GlobalIndex, LayerIdx, TileId,
+};
 use anyhow::Context;
 use macroquad::prelude::*;
+use std::collections::HashMap;
 use std::path::Path;
-use std::thread::yield_now;
 
 pub struct TilesetInfo {
     pub first_gid: u32,
@@ -18,9 +21,27 @@ pub struct TilesetInfo {
     pub margin: u32,
 }
 
+pub struct ObjectLayer {
+    pub name: String,
+    pub visible: bool,
+    pub opacity: f32,
+    pub offset: Vec2,
+    pub properties: Properties,
+    pub objects: Vec<IrObject>,
+}
+
+#[derive(Clone, Copy)]
+struct ObjectRec {
+    object_idx: usize,
+    rel_pos: Vec2,
+}
+
 pub struct Map {
     pub index: GlobalIndex,
     pub tilesets: Vec<TilesetInfo>,
+    object_layers: Vec<ObjectLayer>,
+    object_buckets: HashMap<ChunkCoord, HashMap<usize, Vec<ObjectRec>>>,
+    debug_draw: bool,
     gid_lut: Vec<u16>, //lookup table for tile GIDs to tileset indices
     layer_order: Vec<LayerIdx>,
     pub tile_w: u32,
@@ -41,13 +62,8 @@ impl Map {
             match t {
                 IrTileset::Atlas {
                     first_gid,
-                    image,
-                    tile_w,
-                    tile_h,
                     tilecount,
-                    columns,
-                    spacing,
-                    margin,
+                    ..
                 } => {
                     max_gid = max_gid.max(*first_gid + tilecount - 1);
                 }
@@ -67,6 +83,7 @@ impl Map {
                     columns,
                     spacing,
                     margin,
+                    ..
                 } => {
                     let img_path = base_dir.join(image);
                     let tex = load_texture(img_path.to_str().unwrap())
@@ -93,36 +110,72 @@ impl Map {
         }
 
         let mut index = GlobalIndex::new();
+        let mut object_layers = Vec::new();
+        let mut object_buckets: HashMap<ChunkCoord, HashMap<usize, Vec<ObjectRec>>> =
+            HashMap::new();
         let mut layer_order: Vec<LayerIdx> = Vec::new();
 
         for (lz, layer) in ir.layers.iter().enumerate() {
+            if let IrLayerKind::Objects { objects } = &layer.kind {
+                let layer_idx = object_layers.len();
+                object_layers.push(ObjectLayer {
+                    name: layer.name.clone(),
+                    visible: layer.visible,
+                    opacity: layer.opacity,
+                    offset: layer.offset,
+                    properties: layer.properties.clone(),
+                    objects: objects.clone(),
+                });
+
+                for (object_idx, obj) in objects.iter().enumerate() {
+                    let world = vec2(obj.x, obj.y) + layer.offset;
+                    let (min, max) = Self::object_aabb_world(obj, layer.offset);
+                    let chunk_min = world_to_chunk(min);
+                    let chunk_max = world_to_chunk(max);
+
+                    for cy in chunk_min.y..=chunk_max.y {
+                        for cx in chunk_min.x..=chunk_max.x {
+                            let cc = ChunkCoord { x: cx, y: cy };
+                            let by_layer = object_buckets.entry(cc).or_default();
+                            by_layer.entry(layer_idx).or_default().push(ObjectRec {
+                                object_idx,
+                                rel_pos: rel(world),
+                            });
+                        }
+                    }
+                }
+                continue;
+            }
+
             let lid = lz as LayerIdx;
             let mut inserted_any = false;
 
-            let IrLayerKind::Tiles {
-                width,
-                height,
-                data,
-            } = &layer.kind;
-
-            {
-                let tw = ir.tile_w as f32;
-                let th = ir.tile_h as f32;
-
-                for (idx, gid) in data.iter().enumerate() {
-                    if *gid == 0 {
-                        continue;
-                    }
+            let (width, data) = match &layer.kind {
+                IrLayerKind::Tiles {
+                    width,
+                    height: _,
+                    data,
+                } => (width, data),
+                _ => continue,
+            };
+
+            let tw = ir.tile_w as f32;
+            let th = ir.tile_h as f32;
+
+            for (idx, gid) in data.iter().enumerate() {
+                if *gid == 0 {
+                    continue;
+                }
 
-                    let col = idx % *width;
-                    let row = idx / *width;
-                    let mut world = vec2(col as f32 * tw, row as f32 * th);
-                    world += layer.offset;
+                let col = idx % *width;
+                let row = idx / *width;
+                let mut world = vec2(col as f32 * tw, row as f32 * th);
+                world += layer.offset;
 
-                    index.add_tile(TileId(*gid), lz as LayerIdx, world);
-                    inserted_any = true;
-                }
+                index.add_tile(TileId(*gid), lid, world);
+                inserted_any = true;
             }
+
             if inserted_any {
                 layer_order.push(lid);
             }
@@ -131,6 +184,9 @@ impl Map {
         Ok(Self {
             index,
             tilesets,
+            object_layers,
+            object_buckets,
+            debug_draw: false,
             gid_lut,
             layer_order,
             tile_w: ir.tile_w,
@@ -138,6 +194,61 @@ impl Map {
         })
     }
 
+    fn object_aabb_world(obj: &IrObject, layer_offset: Vec2) -> (Vec2, Vec2) {
+        let origin = vec2(obj.x, obj.y) + layer_offset;
+
+        match &obj.shape {
+            IrObjectShape::Rectangle => {
+                let x2 = origin.x + obj.width;
+                let y2 = origin.y + obj.height;
+                (
+                    vec2(origin.x.min(x2), origin.y.min(y2)),
+                    vec2(origin.x.max(x2), origin.y.max(y2)),
+                )
+            }
+            IrObjectShape::Point => (
+                origin - vec2(0.5, 0.5),
+                origin + vec2(0.5, 0.5),
+            ),
+            IrObjectShape::Polygon(points) | IrObjectShape::Polyline(points) => {
+                if points.is_empty() {
+                    return (origin - vec2(0.5, 0.5), origin + vec2(0.5, 0.5));
+                }
+
+                let mut min_x = origin.x;
+                let mut min_y = origin.y;
+                let mut max_x = origin.x;
+                let mut max_y = origin.y;
+
+                for p in points {
+                    let wp = origin + *p;
+                    min_x = min_x.min(wp.x);
+                    min_y = min_y.min(wp.y);
+                    max_x = max_x.max(wp.x);
+                    max_y = max_y.max(wp.y);
+                }
+
+                (vec2(min_x, min_y), vec2(max_x, max_y))
+            }
+            IrObjectShape::Tile { .. } => {
+                // Tile objects are drawn at (x, y - h), so AABB must match that.
+                let w = if obj.width > 0.0 { obj.width } else { 1.0 };
+                let h = if obj.height > 0.0 { obj.height } else { 1.0 };
+                (vec2(origin.x, origin.y - h), vec2(origin.x + w, origin.y))
+            }
+        }
+    }
+
+    pub fn object_layers(&self) -> &[ObjectLayer] {
+        &self.object_layers
+    }
+
+    pub fn objects(&self) -> impl Iterator<Item = &IrObject> {
+        self.object_layers
+            .iter()
+            .flat_map(|layer| layer.objects.iter())
+    }
+
     #[inline]
     fn params_for_flips(
         &self,
@@ -145,21 +256,20 @@ impl Map {
         tile_w: f32,
         tile_h: f32,
     ) -> (f32, bool, bool, Option<Vec2>) {
-        let h = gid.flip_h(); // horizontal flip
-        let v = gid.flip_v(); // vertical flip
-        let d = gid.flip_d(); // diagonal flip
+        let h = gid.flip_h();
+        let v = gid.flip_v();
+        let d = gid.flip_d();
 
-        let flip_x = h ^ d; // flip horizontally if not diagonal
+        let flip_x = h ^ d;
         let flip_y = v;
         let pivot = Some(vec2(tile_w / 2.0, tile_h / 2.0));
 
         let rotation = match (h, v, d) {
-            (false, _, _) => 0.0, // no flip
-
-            (true, false, false) => std::f32::consts::FRAC_PI_2, // + 90 degrees (with flip)
-            (true, false, true) => std::f32::consts::FRAC_PI_2,  // - 90 defrees
-            (true, true, false) => std::f32::consts::FRAC_PI_2,  // + 90 degrees
-            (true, true, true) => std::f32::consts::PI,          // 180 degrees
+            (false, _, _) => 0.0,
+            (true, false, false) => std::f32::consts::FRAC_PI_2,
+            (true, false, true) => std::f32::consts::FRAC_PI_2,
+            (true, true, false) => std::f32::consts::FRAC_PI_2,
+            (true, true, true) => std::f32::consts::PI,
         };
 
         (rotation, flip_x, flip_y, pivot)
@@ -167,27 +277,17 @@ impl Map {
 
     #[inline]
     fn ts_for_gid(&self, gid: TileId) -> Option<(&TilesetInfo, u32)> {
-        // Clean the tile ID by removing flip/rotation flags, keep only the actual ID number
         let clean = gid.clean() as usize;
-
-        // Check if the cleaned ID is within the bounds of our lookup table
         if clean >= self.gid_lut.len() {
             return None;
         }
 
-        // Get the tileset index from the lookup table
         let idx = self.gid_lut[clean];
-
-        // If the index is u16::MAX, this means the tile ID doesn't map to any tileset
         if idx == u16::MAX {
             return None;
         }
 
-        // Get the tileset info from the tilesets array
         let ts = &self.tilesets[idx as usize];
-
-        // Return the tileset info and the local ID within that tileset
-        // The local ID is calculated by subtracting the tileset's first GID from the cleaned tile ID
         Some((ts, gid.clean() - ts.first_gid))
     }
 
@@ -196,6 +296,28 @@ impl Map {
         self.draw_chunks(view);
     }
 
+    pub fn draw(&self, view_min: Vec2, view_max: Vec2) {
+        self.draw_visible_rect(view_min, view_max);
+        self.draw_objects_tiles(view_min, view_max);
+        if self.debug_draw {
+            self.draw_objects_debug(view_min, view_max);
+        }
+    }
+
+    pub fn set_debug_draw(&mut self, enabled: bool) {
+        self.debug_draw = enabled;
+    }
+
+    pub fn draw_objects_debug(&self, view_min: Vec2, view_max: Vec2) {
+        let view = query_visible_rect(&self.index, view_min, view_max);
+        self.draw_chunk_objects_debug(view);
+    }
+
+    pub fn draw_objects_tiles(&self, view_min: Vec2, view_max: Vec2) {
+        let view = query_visible_rect(&self.index, view_min, view_max);
+        self.draw_chunk_objects_tiles(view);
+    }
+
     fn draw_chunks(&self, view: LocalView) {
         for &layer_id in &self.layer_order {
             for LocalChunkView { coord: cc, layers } in &view.chunks {
@@ -241,4 +363,172 @@ impl Map {
             }
         }
     }
+
+    fn draw_chunk_objects_debug(&self, view: LocalView) {
+        for (layer_idx, layer) in self.object_layers.iter().enumerate() {
+            if !layer.visible {
+                continue;
+            }
+
+            let mut drawn = vec![false; layer.objects.len()];
+
+            for LocalChunkView { coord: cc, .. } in &view.chunks {
+                let Some(by_layer) = self.object_buckets.get(cc) else {
+                    continue;
+                };
+                let Some(records) = by_layer.get(&layer_idx) else {
+                    continue;
+                };
+
+                for rec in records {
+                    if drawn[rec.object_idx] {
+                        continue;
+                    }
+                    drawn[rec.object_idx] = true;
+
+                    let Some(obj) = layer.objects.get(rec.object_idx) else {
+                        continue;
+                    };
+                    if !obj.visible {
+                        continue;
+                    }
+
+                    let origin = vec2(
+                        (cc.x * CHUNK_SIZE) as f32 + rec.rel_pos.x,
+                        (cc.y * CHUNK_SIZE) as f32 + rec.rel_pos.y,
+                    );
+
+                    match &obj.shape {
+                        IrObjectShape::Rectangle => {
+                            draw_rectangle_lines(
+                                origin.x,
+                                origin.y,
+                                obj.width.max(2.0),
+                                obj.height.max(2.0),
+                                2.0,
+                                YELLOW,
+                            );
+                        }
+                        IrObjectShape::Point => {
+                            draw_circle(origin.x, origin.y, 5.0, GREEN);
+                        }
+                        IrObjectShape::Polygon(points) => {
+                            if points.len() < 2 {
+                                continue;
+                            }
+                            for i in 0..points.len() {
+                                let a = origin + points[i];
+                                let b = origin + points[(i + 1) % points.len()];
+                                draw_line(a.x, a.y, b.x, b.y, 2.0, SKYBLUE);
+                            }
+                        }
+                        IrObjectShape::Polyline(points) => {
+                            for seg in points.windows(2) {
+                                let a = origin + seg[0];
+                                let b = origin + seg[1];
+                                draw_line(a.x, a.y, b.x, b.y, 2.0, PINK);
+                            }
+                        }
+                        IrObjectShape::Tile { .. } => {
+                            draw_rectangle_lines(
+                                origin.x,
+                                origin.y - obj.height,
+                                obj.width.max(16.0),
+                                obj.height.max(16.0),
+                                2.0,
+                                MAGENTA,
+                            );
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    fn draw_chunk_objects_tiles(&self, view: LocalView) {
+        for (layer_idx, layer) in self.object_layers.iter().enumerate() {
+            if !layer.visible {
+                continue;
+            }
+
+            let mut drawn = vec![false; layer.objects.len()];
+
+            for LocalChunkView { coord: cc, .. } in &view.chunks {
+                let Some(by_layer) = self.object_buckets.get(cc) else {
+                    continue;
+                };
+                let Some(records) = by_layer.get(&layer_idx) else {
+                    continue;
+                };
+
+                for rec in records {
+                    if drawn[rec.object_idx] {
+                        continue;
+                    }
+                    drawn[rec.object_idx] = true;
+
+                    let Some(obj) = layer.objects.get(rec.object_idx) else {
+                        continue;
+                    };
+                    if !obj.visible {
+                        continue;
+                    }
+
+                    let IrObjectShape::Tile { gid } = obj.shape else {
+                        continue;
+                    };
+
+                    let origin = vec2(
+                        (cc.x * CHUNK_SIZE) as f32 + rec.rel_pos.x,
+                        (cc.y * CHUNK_SIZE) as f32 + rec.rel_pos.y,
+                    );
+
+                    let gid = TileId(gid);
+                    let Some((ts, local)) = self.ts_for_gid(gid) else {
+                        continue;
+                    };
+
+                    let col = local % ts.cols;
+                    let row = local / ts.cols;
+                    let sx = ts.margin + col * (ts.tile_w + ts.spacing);
+                    let sy = ts.margin + row * (ts.tile_h + ts.spacing);
+
+                    let w = if obj.width > 0.0 {
+                        obj.width
+                    } else {
+                        ts.tile_w as f32
+                    };
+                    let h = if obj.height > 0.0 {
+                        obj.height
+                    } else {
+                        ts.tile_h as f32
+                    };
+
+                    let (flag_rotation, flip_x, flip_y, _) = self.params_for_flips(gid, w, h);
+                    let rotation = obj.rotation.to_radians() + flag_rotation;
+
+                    draw_texture_ex(
+                        &ts.tex,
+                        origin.x,
+                        origin.y - h,
+                        WHITE,
+                        DrawTextureParams {
+                            source: Some(Rect::new(
+                                sx as f32,
+                                sy as f32,
+                                ts.tile_w as f32,
+                                ts.tile_h as f32,
+                            )),
+                            dest_size: Some(vec2(w, h)),
+                            rotation,
+                            flip_x,
+                            flip_y,
+                            pivot: Some(vec2(0.0, h)),
+                            ..Default::default()
+                        },
+                    );
+                }
+            }
+        }
+    }
 }
